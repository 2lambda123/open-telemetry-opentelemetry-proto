// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opentelemetry/proto/metrics/v1/metrics.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v11 "github.com/open-telemetry/opentelemetry-proto/gen/go/common/v1"
	v1 "github.com/open-telemetry/opentelemetry-proto/gen/go/resource/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type is the type of values a metric has.
type MetricDescriptor_Type int32

const (
	// TYPE_INVALID is the default Type, it MUST not be used.
	MetricDescriptor_TYPE_INVALID MetricDescriptor_Type = 0
	// INT64 values are represents as signed 64-bit integers.
	//
	// A Metric of this Type MUST assign values to the int64_value field in
	// its Data.
	MetricDescriptor_INT64 MetricDescriptor_Type = 1
	// DOUBLE values are represents as double-precision floating-point
	// numbers.
	//
	// A Metric of this Type MUST assign values to the double_value field
	// in its Data.
	MetricDescriptor_DOUBLE MetricDescriptor_Type = 2
	// DISTRIBUTION values are statistics for an observed population
	// represented. These statistics are represented as a Distribution
	// message.
	//
	// A Metric of this Type MUST assign values to the distribution_value
	// field in its Data.
	MetricDescriptor_DISTRIBUTION MetricDescriptor_Type = 3
)

var MetricDescriptor_Type_name = map[int32]string{
	0: "TYPE_INVALID",
	1: "INT64",
	2: "DOUBLE",
	3: "DISTRIBUTION",
}

var MetricDescriptor_Type_value = map[string]int32{
	"TYPE_INVALID": 0,
	"INT64":        1,
	"DOUBLE":       2,
	"DISTRIBUTION": 3,
}

func (x MetricDescriptor_Type) String() string {
	return proto.EnumName(MetricDescriptor_Type_name, int32(x))
}

func (MetricDescriptor_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 0}
}

// Temporality is the temporal quality values of a metric have. It
// describes how those values relate to the time interval over which they
// are reported.
type MetricDescriptor_Temporality int32

const (
	// TEMPORALITY_INVALID is the default Temporality, it MUST not be
	// used.
	MetricDescriptor_TEMPORALITY_INVALID MetricDescriptor_Temporality = 0
	// INSTANTANEOUS is a metric whose values are measured at a particular
	// instant. The values are not aggregated over any time interval and are
	// unique per timestamp.
	MetricDescriptor_INSTANTANEOUS MetricDescriptor_Temporality = 1
	// DELTA is a metric whose values are the aggregation of measurements
	// made over a time interval. Successive metrics contain aggregation of
	// values from continuous and non-overlapping intervals.
	//
	// The values for a DELTA metric are based only on the time interval
	// associated with one measurement cycle. There is no dependency on
	// previous measurements like is the case for CUMULATIVE metrics.
	//
	// For example, consider a system measuring the number of requests that
	// it receives every second and reports the sum of these requests as a
	// DELTA metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0+1 to
	//      t_0+2 with a value of 2.
	MetricDescriptor_DELTA MetricDescriptor_Temporality = 2
	// CUMULATIVE is a metric whose values are the aggregation of
	// successively made measurements from a fixed start time until the last
	// reported measurement. This means that current values of a CUMULATIVE
	// metric depend on all previous measurements since the start time.
	// Because of this, the sender is required to retain this state in some
	// form. If this state is lost or invalidated, the CUMULATIVE metric
	// values MUST be reset and a new fixed start time following the last
	// reported measurement time sent MUST be used.
	//
	// For example, consider a system measuring the number of requests that
	// it receives every second and reports the sum of these requests as a
	// CUMULATIVE metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+2 with a value of 5.
	//   9. The system experiences a fault and loses state.
	//   10. The system recovers and resumes receiving at time=t_1.
	//   11. A request is received, the system measures 1 request.
	//   12. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_1 to
	//      t_0+1 with a value of 1.
	MetricDescriptor_CUMULATIVE MetricDescriptor_Temporality = 3
)

var MetricDescriptor_Temporality_name = map[int32]string{
	0: "TEMPORALITY_INVALID",
	1: "INSTANTANEOUS",
	2: "DELTA",
	3: "CUMULATIVE",
}

var MetricDescriptor_Temporality_value = map[string]int32{
	"TEMPORALITY_INVALID": 0,
	"INSTANTANEOUS":       1,
	"DELTA":               2,
	"CUMULATIVE":          3,
}

func (x MetricDescriptor_Temporality) String() string {
	return proto.EnumName(MetricDescriptor_Temporality_name, int32(x))
}

func (MetricDescriptor_Temporality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 1}
}

// Monotonic is a refinement of the values a metric has. It defines the
// relationship values of successively reported metrics have
// (non-increasing, non-decreasing, or unknown). This is a refinement of
// the metric values that can be useful for a receiver in understanding
// how to deal with discontinuities in the data (i.e.  calculating
// derivates of the data without introducing artifacts from a reset).
type MetricDescriptor_Monotonic int32

const (
	// MONOTONIC_UNSPECIFIED is the default, and means the monotonic nature
	// of the metric values is unknown.
	MetricDescriptor_MONOTONIC_UNSPECIFIED MetricDescriptor_Monotonic = 0
	// NONDECREASING means all the successive metric values increase or
	// remain constant.
	MetricDescriptor_NONDECREASING MetricDescriptor_Monotonic = 1
)

var MetricDescriptor_Monotonic_name = map[int32]string{
	0: "MONOTONIC_UNSPECIFIED",
	1: "NONDECREASING",
}

var MetricDescriptor_Monotonic_value = map[string]int32{
	"MONOTONIC_UNSPECIFIED": 0,
	"NONDECREASING":         1,
}

func (x MetricDescriptor_Monotonic) String() string {
	return proto.EnumName(MetricDescriptor_Monotonic_name, int32(x))
}

func (MetricDescriptor_Monotonic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 2}
}

// Domain is a refinement of the values a metric has. It describes the set
// of numbers metric values belong to, if any.
type MetricDescriptor_Domain int32

const (
	// DOMAIN_UNSPECIFIED is the default, and means the metric values do
	// not belong to any particular domain other than the Type itself.
	MetricDescriptor_DOMAIN_UNSPECIFIED MetricDescriptor_Domain = 0
	// NONNEGATIVE is the set of numbers greater than or equal to zero.
	MetricDescriptor_NONNEGATIVE MetricDescriptor_Domain = 1
)

var MetricDescriptor_Domain_name = map[int32]string{
	0: "DOMAIN_UNSPECIFIED",
	1: "NONNEGATIVE",
}

var MetricDescriptor_Domain_value = map[string]int32{
	"DOMAIN_UNSPECIFIED": 0,
	"NONNEGATIVE":        1,
}

func (x MetricDescriptor_Domain) String() string {
	return proto.EnumName(MetricDescriptor_Domain_name, int32(x))
}

func (MetricDescriptor_Domain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 3}
}

// A collection of InstrumentationLibraryMetrics from a Resource.
type ResourceMetrics struct {
	// The resource for the metrics in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of metrics that originate from a resource.
	InstrumentationLibraryMetrics []*InstrumentationLibraryMetrics `protobuf:"bytes,2,rep,name=instrumentation_library_metrics,json=instrumentationLibraryMetrics,proto3" json:"instrumentation_library_metrics,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                         `json:"-"`
	XXX_unrecognized              []byte                           `json:"-"`
	XXX_sizecache                 int32                            `json:"-"`
}

func (m *ResourceMetrics) Reset()         { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()    {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{0}
}

func (m *ResourceMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceMetrics.Unmarshal(m, b)
}
func (m *ResourceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceMetrics.Marshal(b, m, deterministic)
}
func (m *ResourceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMetrics.Merge(m, src)
}
func (m *ResourceMetrics) XXX_Size() int {
	return xxx_messageInfo_ResourceMetrics.Size(m)
}
func (m *ResourceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMetrics proto.InternalMessageInfo

func (m *ResourceMetrics) GetResource() *v1.Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceMetrics) GetInstrumentationLibraryMetrics() []*InstrumentationLibraryMetrics {
	if m != nil {
		return m.InstrumentationLibraryMetrics
	}
	return nil
}

// A collection of Metrics produced by an InstrumentationLibrary.
type InstrumentationLibraryMetrics struct {
	// The instrumentation library information for the metrics in this message.
	// If this field is not set then no library info is known.
	InstrumentationLibrary *v11.InstrumentationLibrary `protobuf:"bytes,1,opt,name=instrumentation_library,json=instrumentationLibrary,proto3" json:"instrumentation_library,omitempty"`
	// A list of metrics that originate from an instrumentation library.
	Metrics              []*Metric `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstrumentationLibraryMetrics) Reset()         { *m = InstrumentationLibraryMetrics{} }
func (m *InstrumentationLibraryMetrics) String() string { return proto.CompactTextString(m) }
func (*InstrumentationLibraryMetrics) ProtoMessage()    {}
func (*InstrumentationLibraryMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{1}
}

func (m *InstrumentationLibraryMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Unmarshal(m, b)
}
func (m *InstrumentationLibraryMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Marshal(b, m, deterministic)
}
func (m *InstrumentationLibraryMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstrumentationLibraryMetrics.Merge(m, src)
}
func (m *InstrumentationLibraryMetrics) XXX_Size() int {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Size(m)
}
func (m *InstrumentationLibraryMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_InstrumentationLibraryMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_InstrumentationLibraryMetrics proto.InternalMessageInfo

func (m *InstrumentationLibraryMetrics) GetInstrumentationLibrary() *v11.InstrumentationLibrary {
	if m != nil {
		return m.InstrumentationLibrary
	}
	return nil
}

func (m *InstrumentationLibraryMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Metric represents a timeseries produced by a telemetry system.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a list of label keys (shown horizontally).
// - Data is a list of DataPoints (shown vertically).
// - DataPoint contains a list of label values and a value.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         |+-----+-----+   +-----+ |
//  |          |         ||label|label|...|label| |
//  |      data|--+      ||key1 |key2 |   |keyN | |
//  +----------+  |      |+-----+-----+   +-----+ |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
type Metric struct {
	// metric_descriptor describing this Metric.
	MetricDescriptor *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor,proto3" json:"metric_descriptor,omitempty"`
	// start_time_unix_nano is the beginning of the time interval over which
	// all data for this Metric were recorded. It MUST be represented as the
	// UNIX Epoch time in nanoseconds (nanoseconds since 00:00:00 UTC on 1
	// January 1970). If zero, it is treated as unspecified.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// end_time_unix_nano is the end of the time interval over which all data
	// for this Metric were recorded. It MUST be represented as the UNIX Epoch
	// time in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970).
	// If zero, it is treated as unspecified and the end to the time interval
	// is define by the receiver as the time this data is received. It is
	// RECOMMENDED to not leave this unspecified.
	EndTimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// Data values of this Metric.
	Data                 []*Metric_Data `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Metric) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Metric) GetData() []*Metric_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type Metric_Data struct {
	// The set of additional labels uniquely identifying this data.
	//
	// It is considered an error for Labels used here to have the same key
	// as those defined in this Metric's MetricDescriptor and MUST be
	// avoided. The handling of this error is left up to the receiver.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the beginning of the time interval over which
	// this data was recorded. It MUST be represented as the UNIX Epoch time
	// in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
	// zero, it is treated as unspecified.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// end_time_unix_nano is the end of the time interval over which this
	// data was recorded. It MUST be represented as the UNIX Epoch time in
	// nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
	// zero, it is treated as unspecified.
	EndTimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// int64_value contains the measured value for INT64 type Metrics.
	Int64Value int64 `protobuf:"varint,4,opt,name=int64_value,json=int64Value,proto3" json:"int64_value,omitempty"`
	// double_value contains the measured value for DOUBLE type Metrics.
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue,proto3" json:"double_value,omitempty"`
	// distribution_value contains the measured value for DISTRIBUTION type
	// Metrics.
	DistributionValue    *Distribution `protobuf:"bytes,6,opt,name=distribution_value,json=distributionValue,proto3" json:"distribution_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metric_Data) Reset()         { *m = Metric_Data{} }
func (m *Metric_Data) String() string { return proto.CompactTextString(m) }
func (*Metric_Data) ProtoMessage()    {}
func (*Metric_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2, 0}
}

func (m *Metric_Data) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric_Data.Unmarshal(m, b)
}
func (m *Metric_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric_Data.Marshal(b, m, deterministic)
}
func (m *Metric_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric_Data.Merge(m, src)
}
func (m *Metric_Data) XXX_Size() int {
	return xxx_messageInfo_Metric_Data.Size(m)
}
func (m *Metric_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Metric_Data proto.InternalMessageInfo

func (m *Metric_Data) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric_Data) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Metric_Data) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Metric_Data) GetInt64Value() int64 {
	if m != nil {
		return m.Int64Value
	}
	return 0
}

func (m *Metric_Data) GetDoubleValue() float64 {
	if m != nil {
		return m.DoubleValue
	}
	return 0
}

func (m *Metric_Data) GetDistributionValue() *Distribution {
	if m != nil {
		return m.DistributionValue
	}
	return nil
}

// MetricDescriptor describes the identifying attributes of a metric.
type MetricDescriptor struct {
	// name of the metric.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description of the metric. This description is commonly used in
	// documentation so it should be a human-readable explanation of the
	// metric.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// type is the Type of values this metric has.
	Type MetricDescriptor_Type `protobuf:"varint,4,opt,name=type,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Type" json:"type,omitempty"`
	// temporality is the Temporality of values this metric has.
	Temporality MetricDescriptor_Temporality `protobuf:"varint,5,opt,name=temporality,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality" json:"temporality,omitempty"`
	// monotonic describes the Monotonic refinement of values this metric has.
	Monotonic MetricDescriptor_Monotonic `protobuf:"varint,6,opt,name=monotonic,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Monotonic" json:"monotonic,omitempty"`
	// domain describes the Domain refinement of values this metric has.
	Domain MetricDescriptor_Domain `protobuf:"varint,7,opt,name=domain,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Domain" json:"domain,omitempty"`
	// The set of labels associated with the metric descriptor. Labels in this
	// list apply to all data points.
	Labels               []*v11.StringKeyValue `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetricDescriptor) Reset()         { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()    {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3}
}

func (m *MetricDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricDescriptor.Unmarshal(m, b)
}
func (m *MetricDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricDescriptor.Marshal(b, m, deterministic)
}
func (m *MetricDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDescriptor.Merge(m, src)
}
func (m *MetricDescriptor) XXX_Size() int {
	return xxx_messageInfo_MetricDescriptor.Size(m)
}
func (m *MetricDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDescriptor proto.InternalMessageInfo

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetType() MetricDescriptor_Type {
	if m != nil {
		return m.Type
	}
	return MetricDescriptor_TYPE_INVALID
}

func (m *MetricDescriptor) GetTemporality() MetricDescriptor_Temporality {
	if m != nil {
		return m.Temporality
	}
	return MetricDescriptor_TEMPORALITY_INVALID
}

func (m *MetricDescriptor) GetMonotonic() MetricDescriptor_Monotonic {
	if m != nil {
		return m.Monotonic
	}
	return MetricDescriptor_MONOTONIC_UNSPECIFIED
}

func (m *MetricDescriptor) GetDomain() MetricDescriptor_Domain {
	if m != nil {
		return m.Domain
	}
	return MetricDescriptor_DOMAIN_UNSPECIFIED
}

func (m *MetricDescriptor) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Distribution is a data point in a timeseries containing statistics for
// an observed population of values.
type Distribution struct {
	// count is the number of values in a population.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// sum is the total sum of all values in a population.
	Sum float64 `protobuf:"fixed64,2,opt,name=sum,proto3" json:"sum,omitempty"`
	// minimum is the minimum observed value in a population.
	Minimum float64 `protobuf:"fixed64,3,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// maximum is the maximum observed value in a population.
	Maximum float64 `protobuf:"fixed64,4,opt,name=maximum,proto3" json:"maximum,omitempty"`
	// buckets is an optional field contains the values of histogram for each bucket.
	//
	// The sum of the values in the buckets "count" field must equal the value in the count field.
	//
	// The number of elements in buckets array must be by one greater than the
	// number of elements in bucket_bounds array.
	//
	// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
	// must also be present and number of elements in this field must be equal to the
	// number of buckets defined by bucket_options.
	Buckets []*Distribution_Bucket `protobuf:"bytes,5,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// explicit_bounds specifies buckets with explicitly defined bounds for values.
	// The bucket boundaries are described by "bounds" field.
	//
	// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
	// at index i are:
	//
	// [0, bounds[i]) for i == 0
	// [bounds[i-1], bounds[i]) for 0 < i < N-1
	// [bounds[i], +infinity) for i == N-1
	// The values in bounds array must be strictly increasing and > 0.
	//
	// Note: only [a, b) intervals are currently supported for each bucket. If we decides
	// to also support (a, b] intervals we should add support for these by defining a boolean
	// value which decides what type of intervals to use.
	ExplicitBounds       []float64 `protobuf:"fixed64,6,rep,packed,name=explicit_bounds,json=explicitBounds,proto3" json:"explicit_bounds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Distribution) Reset()         { *m = Distribution{} }
func (m *Distribution) String() string { return proto.CompactTextString(m) }
func (*Distribution) ProtoMessage()    {}
func (*Distribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4}
}

func (m *Distribution) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution.Unmarshal(m, b)
}
func (m *Distribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution.Marshal(b, m, deterministic)
}
func (m *Distribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution.Merge(m, src)
}
func (m *Distribution) XXX_Size() int {
	return xxx_messageInfo_Distribution.Size(m)
}
func (m *Distribution) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution proto.InternalMessageInfo

func (m *Distribution) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Distribution) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Distribution) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Distribution) GetBuckets() []*Distribution_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Distribution) GetExplicitBounds() []float64 {
	if m != nil {
		return m.ExplicitBounds
	}
	return nil
}

// Bucket contains values for a bucket.
type Distribution_Bucket struct {
	// The number of values in each bucket of the histogram, as described by
	// bucket_options.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// exemplar is an optional representative value of the bucket.
	Exemplar             *Distribution_Bucket_Exemplar `protobuf:"bytes,2,opt,name=exemplar,proto3" json:"exemplar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Distribution_Bucket) Reset()         { *m = Distribution_Bucket{} }
func (m *Distribution_Bucket) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket) ProtoMessage()    {}
func (*Distribution_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0}
}

func (m *Distribution_Bucket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket.Unmarshal(m, b)
}
func (m *Distribution_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket.Merge(m, src)
}
func (m *Distribution_Bucket) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket.Size(m)
}
func (m *Distribution_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket proto.InternalMessageInfo

func (m *Distribution_Bucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution_Bucket) GetExemplar() *Distribution_Bucket_Exemplar {
	if m != nil {
		return m.Exemplar
	}
	return nil
}

// Exemplars are example points that may be used to annotate aggregated
// Histogram values. They are metadata that gives information about a
// particular value added to a Histogram bucket.
type Distribution_Bucket_Exemplar struct {
	// Value of the exemplar point. It determines which bucket the exemplar belongs to.
	// If bucket_options define bounds for this bucket then this value must be within
	// the defined bounds.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// end_time_unix_nano is the moment when this exemplar was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	EndTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// exemplar_attachments are contextual information about the example value.
	// Keys in this list must be unique.
	Attachments          []*v11.StringKeyValue `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Distribution_Bucket_Exemplar) Reset()         { *m = Distribution_Bucket_Exemplar{} }
func (m *Distribution_Bucket_Exemplar) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket_Exemplar) ProtoMessage()    {}
func (*Distribution_Bucket_Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0, 0}
}

func (m *Distribution_Bucket_Exemplar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Unmarshal(m, b)
}
func (m *Distribution_Bucket_Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket_Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket_Exemplar.Merge(m, src)
}
func (m *Distribution_Bucket_Exemplar) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Size(m)
}
func (m *Distribution_Bucket_Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket_Exemplar proto.InternalMessageInfo

func (m *Distribution_Bucket_Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetAttachments() []*v11.StringKeyValue {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Type", MetricDescriptor_Type_name, MetricDescriptor_Type_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality", MetricDescriptor_Temporality_name, MetricDescriptor_Temporality_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Monotonic", MetricDescriptor_Monotonic_name, MetricDescriptor_Monotonic_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Domain", MetricDescriptor_Domain_name, MetricDescriptor_Domain_value)
	proto.RegisterType((*ResourceMetrics)(nil), "opentelemetry.proto.metrics.v1.ResourceMetrics")
	proto.RegisterType((*InstrumentationLibraryMetrics)(nil), "opentelemetry.proto.metrics.v1.InstrumentationLibraryMetrics")
	proto.RegisterType((*Metric)(nil), "opentelemetry.proto.metrics.v1.Metric")
	proto.RegisterType((*Metric_Data)(nil), "opentelemetry.proto.metrics.v1.Metric.Data")
	proto.RegisterType((*MetricDescriptor)(nil), "opentelemetry.proto.metrics.v1.MetricDescriptor")
	proto.RegisterType((*Distribution)(nil), "opentelemetry.proto.metrics.v1.Distribution")
	proto.RegisterType((*Distribution_Bucket)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket")
	proto.RegisterType((*Distribution_Bucket_Exemplar)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket.Exemplar")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/metrics/v1/metrics.proto", fileDescriptor_3c3112f9fa006917)
}

var fileDescriptor_3c3112f9fa006917 = []byte{
	// 1008 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0x71, 0x92, 0xba, 0xcd, 0x4b, 0x69, 0xdd, 0x61, 0xd9, 0x35, 0x95, 0x96, 0xcd, 0xe6,
	0x00, 0x81, 0xdd, 0x3a, 0xb4, 0xbb, 0x2c, 0x02, 0x81, 0x96, 0xa4, 0x31, 0x2b, 0x8b, 0xc4, 0xae,
	0x26, 0x4e, 0xb5, 0x0b, 0x82, 0xc8, 0x49, 0x46, 0xdd, 0x11, 0xf1, 0x4c, 0x64, 0x8f, 0xab, 0xe6,
	0xc6, 0x85, 0x3f, 0x82, 0x0b, 0x7f, 0x11, 0x17, 0x0e, 0xdc, 0xf9, 0x4b, 0x10, 0xf2, 0x8c, 0xdd,
	0xba, 0x55, 0xda, 0x6c, 0x41, 0xdc, 0x66, 0xde, 0x8f, 0xcf, 0xbc, 0xf9, 0xfa, 0xcd, 0x78, 0xe0,
	0x31, 0x9f, 0x13, 0x26, 0xc8, 0x8c, 0x84, 0x44, 0x44, 0x8b, 0xd6, 0x3c, 0xe2, 0x82, 0xb7, 0xd2,
	0x31, 0x9d, 0xc4, 0xad, 0xd3, 0xfd, 0x7c, 0x68, 0x49, 0x07, 0x7a, 0xff, 0x52, 0xb4, 0x32, 0x5a,
	0x79, 0xc8, 0xe9, 0xfe, 0xee, 0xc7, 0xcb, 0x68, 0x13, 0x1e, 0x86, 0x9c, 0xa5, 0x30, 0x35, 0x52,
	0x69, 0xbb, 0xd6, 0xb2, 0xd8, 0x88, 0xc4, 0x3c, 0x89, 0x26, 0x24, 0x8d, 0xce, 0xc7, 0x2a, 0xbe,
	0xf1, 0x97, 0x06, 0xdb, 0x38, 0x33, 0xf5, 0xd5, 0x92, 0xc8, 0x86, 0x8d, 0x3c, 0xca, 0xd4, 0xea,
	0x5a, 0xb3, 0x76, 0xf0, 0x91, 0xb5, 0xac, 0xc4, 0x73, 0xd4, 0xe9, 0xbe, 0x95, 0x33, 0xf0, 0x79,
	0x2a, 0xfa, 0x45, 0x83, 0x07, 0x94, 0xc5, 0x22, 0x4a, 0x42, 0xc2, 0x44, 0x20, 0x28, 0x67, 0xa3,
	0x19, 0x1d, 0x47, 0x41, 0xb4, 0x18, 0x65, 0xbb, 0x33, 0x4b, 0xf5, 0x72, 0xb3, 0x76, 0xf0, 0x95,
	0x75, 0xb3, 0x02, 0x96, 0x73, 0x19, 0xd3, 0x53, 0x94, 0xac, 0x5e, 0x7c, 0x9f, 0xde, 0xe4, 0x6e,
	0xfc, 0xa1, 0xc1, 0xfd, 0x1b, 0x01, 0x88, 0xc1, 0xbd, 0x6b, 0x0a, 0xcd, 0xf6, 0xff, 0xe9, 0xd2,
	0x02, 0x33, 0xe1, 0xaf, 0xad, 0x0f, 0xdf, 0x5d, 0x5e, 0x18, 0xfa, 0x1a, 0xd6, 0x2f, 0x0b, 0xf0,
	0xc1, 0x2a, 0x01, 0x54, 0xa5, 0x38, 0x4f, 0x6b, 0xfc, 0x59, 0x01, 0x5d, 0xd9, 0xd0, 0x0f, 0xb0,
	0xa3, 0xac, 0xa3, 0x29, 0x89, 0x27, 0x11, 0x9d, 0x0b, 0x1e, 0x65, 0x65, 0x7f, 0xf2, 0x66, 0xd8,
	0xee, 0x79, 0x1e, 0x36, 0xc2, 0x2b, 0x16, 0xd4, 0x82, 0x3b, 0xb1, 0x08, 0x22, 0x31, 0x12, 0x34,
	0x24, 0xa3, 0x84, 0xd1, 0xb3, 0x11, 0x0b, 0x18, 0x37, 0x4b, 0x75, 0xad, 0xa9, 0xe3, 0x1d, 0xe9,
	0xf3, 0x69, 0x48, 0x86, 0x8c, 0x9e, 0xb9, 0x01, 0xe3, 0xe8, 0x11, 0x20, 0xc2, 0xa6, 0x57, 0xc3,
	0xcb, 0x32, 0x7c, 0x9b, 0xb0, 0xe9, 0xa5, 0xe0, 0xe7, 0x50, 0x99, 0x06, 0x22, 0x30, 0x2b, 0x52,
	0x86, 0x47, 0x6f, 0x56, 0xaf, 0xd5, 0x0d, 0x44, 0x80, 0x65, 0xe2, 0xee, 0xef, 0x25, 0xa8, 0xa4,
	0x53, 0x64, 0x83, 0x3e, 0x0b, 0xc6, 0x64, 0x16, 0x9b, 0x9a, 0x64, 0xed, 0xad, 0xf8, 0x64, 0x03,
	0x11, 0x51, 0x76, 0xf2, 0x2d, 0x59, 0x1c, 0x07, 0xb3, 0x84, 0xe0, 0x2c, 0xf9, 0x7f, 0xde, 0xee,
	0x03, 0xa8, 0x51, 0x26, 0x9e, 0x3d, 0x1d, 0x9d, 0xa6, 0x8b, 0x9a, 0x95, 0xba, 0xd6, 0x2c, 0x63,
	0x90, 0x26, 0x59, 0x06, 0x7a, 0x08, 0x9b, 0x53, 0x9e, 0x8c, 0x67, 0x24, 0x8b, 0x58, 0xab, 0x6b,
	0x4d, 0x0d, 0xd7, 0x94, 0x4d, 0x85, 0x7c, 0x0f, 0x68, 0x4a, 0x63, 0x11, 0xd1, 0x71, 0x22, 0x3b,
	0x55, 0x05, 0xea, 0xf2, 0x83, 0x3f, 0x5e, 0x25, 0x60, 0xb7, 0x90, 0x89, 0x77, 0x8a, 0x1c, 0x09,
	0x6f, 0xfc, 0xac, 0x83, 0x71, 0xb5, 0x29, 0x10, 0x82, 0x0a, 0x0b, 0x42, 0x75, 0x17, 0x54, 0xb1,
	0x1c, 0xa3, 0x3a, 0xd4, 0xf2, 0x76, 0xa3, 0x9c, 0x49, 0x79, 0xaa, 0xb8, 0x68, 0x4a, 0xb3, 0x12,
	0x46, 0x85, 0x94, 0xa2, 0x8a, 0xe5, 0x18, 0x39, 0x50, 0x11, 0x8b, 0xb9, 0xda, 0xf8, 0xd6, 0x35,
	0xa7, 0xea, 0x86, 0xf6, 0xb4, 0xfc, 0xc5, 0x9c, 0x60, 0x89, 0x40, 0x3f, 0x42, 0x4d, 0x90, 0x70,
	0xce, 0xa3, 0x60, 0x46, 0xc5, 0x42, 0x0a, 0xb5, 0x75, 0xf0, 0xe5, 0xed, 0x89, 0x17, 0x0c, 0x5c,
	0x04, 0xa2, 0x97, 0x50, 0x0d, 0x39, 0xe3, 0x82, 0x33, 0x3a, 0x91, 0xea, 0x6e, 0x1d, 0x7c, 0x71,
	0x6b, 0x7a, 0x3f, 0x27, 0xe0, 0x0b, 0x18, 0xf2, 0x40, 0x9f, 0xf2, 0x30, 0xa0, 0xcc, 0x5c, 0x97,
	0xd8, 0xcf, 0x6e, 0x8d, 0xed, 0xca, 0x74, 0x9c, 0x61, 0x0a, 0xad, 0xbf, 0xf1, 0x1f, 0x5a, 0xbf,
	0xd1, 0x86, 0x4a, 0xaa, 0x2f, 0x32, 0x60, 0xd3, 0x7f, 0x75, 0x64, 0x8f, 0x1c, 0xf7, 0xb8, 0xdd,
	0x73, 0xba, 0xc6, 0x5b, 0xa8, 0x0a, 0x6b, 0x8e, 0xeb, 0x3f, 0x7b, 0x6a, 0x68, 0x08, 0x40, 0xef,
	0x7a, 0xc3, 0x4e, 0xcf, 0x36, 0x4a, 0x69, 0x60, 0xd7, 0x19, 0xf8, 0xd8, 0xe9, 0x0c, 0x7d, 0xc7,
	0x73, 0x8d, 0x72, 0xc3, 0x87, 0x5a, 0x41, 0x50, 0x74, 0x0f, 0xde, 0xf1, 0xed, 0xfe, 0x91, 0x87,
	0xdb, 0x3d, 0xc7, 0x7f, 0x55, 0x00, 0xee, 0xc0, 0xdb, 0x8e, 0x3b, 0xf0, 0xdb, 0xae, 0xdf, 0x76,
	0x6d, 0x6f, 0x38, 0x30, 0xb4, 0x74, 0x8d, 0xae, 0xdd, 0xf3, 0xdb, 0x46, 0x09, 0x6d, 0x01, 0x1c,
	0x0e, 0xfb, 0xc3, 0x5e, 0xdb, 0x77, 0x8e, 0x6d, 0xa3, 0xdc, 0xf8, 0x1c, 0xaa, 0xe7, 0x42, 0xa2,
	0xf7, 0xe0, 0xdd, 0xbe, 0xe7, 0x7a, 0xbe, 0xe7, 0x3a, 0x87, 0xa3, 0xa1, 0x3b, 0x38, 0xb2, 0x0f,
	0x9d, 0x6f, 0x1c, 0x3b, 0xa3, 0xba, 0x9e, 0xdb, 0xb5, 0x0f, 0xb1, 0xdd, 0x1e, 0x38, 0xee, 0x0b,
	0x43, 0x6b, 0xec, 0x83, 0xae, 0xc4, 0x42, 0x77, 0x01, 0x75, 0xbd, 0x7e, 0xdb, 0x71, 0xaf, 0x24,
	0x6d, 0x43, 0xcd, 0xf5, 0x5c, 0xd7, 0x7e, 0xa1, 0x56, 0xd3, 0x1a, 0x7f, 0x97, 0x61, 0xb3, 0x78,
	0x4c, 0xd0, 0x1d, 0x58, 0x9b, 0xf0, 0x84, 0x09, 0xd9, 0xff, 0x15, 0xac, 0x26, 0xc8, 0x80, 0x72,
	0x9c, 0x84, 0xb2, 0xf1, 0x35, 0x9c, 0x0e, 0x91, 0x09, 0xeb, 0x21, 0x65, 0x34, 0x4c, 0x42, 0xd9,
	0xf3, 0x1a, 0xce, 0xa7, 0xd2, 0x13, 0x9c, 0x49, 0x4f, 0x25, 0xf3, 0xa8, 0x29, 0xea, 0xc3, 0xfa,
	0x38, 0x99, 0xfc, 0x44, 0x44, 0x6c, 0xae, 0xc9, 0x6f, 0xf7, 0xe4, 0x36, 0x27, 0xd8, 0xea, 0xc8,
	0x5c, 0x9c, 0x33, 0xd0, 0x87, 0xb0, 0x4d, 0xce, 0xe6, 0x33, 0x3a, 0xa1, 0x62, 0x34, 0xe6, 0x09,
	0x9b, 0xc6, 0xa6, 0x5e, 0x2f, 0x37, 0x35, 0xbc, 0x95, 0x9b, 0x3b, 0xd2, 0xba, 0xfb, 0x6b, 0x09,
	0x74, 0x95, 0x7c, 0xcd, 0xf6, 0x5e, 0xc2, 0x06, 0x39, 0x23, 0xe1, 0x7c, 0x16, 0x44, 0x72, 0x8f,
	0xb5, 0xd5, 0x67, 0x6b, 0x49, 0x65, 0x96, 0x9d, 0x31, 0xf0, 0x39, 0x6d, 0xf7, 0x37, 0x0d, 0x36,
	0x72, 0x73, 0xba, 0xb8, 0xba, 0xbf, 0x34, 0xa9, 0x8b, 0x9a, 0x5c, 0x73, 0xa7, 0x96, 0x96, 0xdf,
	0xa9, 0x1e, 0xd4, 0x02, 0x21, 0x82, 0xc9, 0xeb, 0xf4, 0x37, 0x1b, 0x9b, 0xe5, 0x7f, 0x73, 0x04,
	0x8a, 0x84, 0x8e, 0x80, 0x87, 0x94, 0xaf, 0xd8, 0x6c, 0x67, 0x33, 0x7b, 0x3b, 0x1c, 0xa5, 0x8e,
	0x23, 0xed, 0xbb, 0xe7, 0x27, 0x54, 0xbc, 0x4e, 0xc6, 0xe9, 0x12, 0xad, 0x34, 0x75, 0xef, 0xe2,
	0x0d, 0x76, 0x89, 0xb4, 0xa7, 0x5e, 0x64, 0x27, 0x84, 0xb5, 0x4e, 0x8a, 0x4f, 0xc2, 0xb1, 0x2e,
	0x1d, 0x4f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x15, 0x1e, 0x46, 0x53, 0x3b, 0x0a, 0x00, 0x00,
}
