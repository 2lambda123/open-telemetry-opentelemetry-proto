// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opentelemetry/proto/metrics/v1/metrics.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v11 "github.com/open-telemetry/opentelemetry-proto/gen/go/common/v1"
	v1 "github.com/open-telemetry/opentelemetry-proto/gen/go/resource/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ValueType is the type of values a metric has.  ValueType
// determines which field of the DataPoint will be used for Metrics
// with this descriptor.  See the definition of Kind for detail on
// which aggregations may be expressed for which instruments using
// which value types.
type MetricDescriptor_ValueType int32

const (
	// INVALID_TYPE is the default ValueType, it MUST not be used.
	MetricDescriptor_INVALID_VALUE_TYPE MetricDescriptor_ValueType = 0
	// ScalarInt64 implies that the value is found in
	// Metric.int64_data_points[].value.
	MetricDescriptor_SCALAR_INT64 MetricDescriptor_ValueType = 1
	// ScalarDouble implies that the value is found in
	// Metric.double_data_points[].value.
	MetricDescriptor_SCALAR_DOUBLE MetricDescriptor_ValueType = 2
	// Histogram implies that the value is found in
	// Metric.histogram_data_points[].histogram.
	MetricDescriptor_HISTOGRAM MetricDescriptor_ValueType = 3
	// Summary implies that the value is found in
	// Metric.summary_data_points[].summary.
	MetricDescriptor_SUMMARY MetricDescriptor_ValueType = 4
)

var MetricDescriptor_ValueType_name = map[int32]string{
	0: "INVALID_VALUE_TYPE",
	1: "SCALAR_INT64",
	2: "SCALAR_DOUBLE",
	3: "HISTOGRAM",
	4: "SUMMARY",
}

var MetricDescriptor_ValueType_value = map[string]int32{
	"INVALID_VALUE_TYPE": 0,
	"SCALAR_INT64":       1,
	"SCALAR_DOUBLE":      2,
	"HISTOGRAM":          3,
	"SUMMARY":            4,
}

func (x MetricDescriptor_ValueType) String() string {
	return proto.EnumName(MetricDescriptor_ValueType_name, int32(x))
}

func (MetricDescriptor_ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 0}
}

// KindElement contains a set of bit masks used to construct Kind
// enum values.  There are 7 bits used presently, broken into
// groups:
//
// "Temporality" is the temporal quality of a metric, indicating how
// values relate to the time interval over which they are reported.
// One of the 3 Temporality values MUST be set: CUMULATIVE, DELTA,
// or INSTANTANEOUS.
//
// "Structure" is the structural quality of a metric, indicating
// whether metric data describes a sum of measurements (ADDING),
// whether it is a monotonic sum (ADDING_MONOTONIC), or a
// collection of individual measurements (GROUPING).  Value types
// may be interpreted differently depending on Structure.  For
// example, a Histogram DataPoint may be computed for a Counter
// (ADDING) instrument or a ValueRecorder (GROUPING) instrument, and
// the Sum and Count of the resulting aggregation may be interpreted
// differently depending on structure.
//
// SNAPSHOT is a boolean option that may be applied to all
// metrics, meaning that it was generated periodically, at a
// time determined by the SDK.  OpenTelemetry Observer instruments
// report SNAPSHOT measurements, with observations from a
// single callback invokation sharing a single logical timestamp.
// This property can be safetly disregarded and not set when
// importing data from other sources, but when set its presence is
// always meaningful.
//
// When measurements originate from an OpenTelemetry API, the
// SNAPSHOT kind allows the interpreter to recognize values
// that were emitted by the same callback invocation, as identified
// by equal Resource and TimeUnixNano values.  SNAPSHOT metrics
// MUST NOT have more than one data point per TimeUnixNano,
// Resource, and LabelSet.  If the interpreter of this data finds
// such matching data points, they are considered duplicate by
// definition and all but one SHOULD be discarded.
//
// SNAPSHOT means that:
// - The count of events is a measure of the rate of SDK collection
//   times the aggregated cardinality, therefore cannot be used
//   to extrapolate application-specific rate information.
// - Measurements with the same Resource and TimeUnixNano
//   form a meaningful ratio, and the set of measurements at this
//   instant are coherent at the point-in-time, as they result from
//   a single callback.
// - Measurements are not traced, by definition, and SHOULD NOT have
//   associated trace context (e.g., no exemplars with trace_id,
//   span_id).
//
// SNAPSHOT is incompatible with INSTANTANEOUS.
type MetricDescriptor_KindElement int32

const (
	// INVALID_KIND_ELEMENT is not used.
	MetricDescriptor_INVALID_KIND_ELEMENT MetricDescriptor_KindElement = 0
	// INSTANTANEOUS is a metric whose values are measured at a particular
	// instant. The values are not aggregated over any time interval and are
	// unique per timestamp. As such, these metrics are not expected to have
	// an associated start time.
	MetricDescriptor_INSTANTANEOUS MetricDescriptor_KindElement = 1
	// DELTA is a metric whose values are the aggregation of measurements
	// made over a time interval. Successive metrics contain aggregation of
	// values from continuous and non-overlapping intervals.
	//
	// The values for a DELTA metric are based only on the time interval
	// associated with one measurement cycle. There is no dependency on
	// previous measurements like is the case for CUMULATIVE metrics.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// DELTA metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0+1 to
	//      t_0+2 with a value of 2.
	MetricDescriptor_DELTA MetricDescriptor_KindElement = 2
	// CUMULATIVE is a metric whose values are the aggregation of
	// successively made measurements from a fixed start time until the last
	// reported measurement. This means that current values of a CUMULATIVE
	// metric depend on all previous measurements since the start time.
	// Because of this, the sender is required to retain this state in some
	// form. If this state is lost or invalidated, the CUMULATIVE metric
	// values MUST be reset and a new fixed start time following the last
	// reported measurement time sent MUST be used.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// CUMULATIVE metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+2 with a value of 5.
	//   9. The system experiences a fault and loses state.
	//   10. The system recovers and resumes receiving at time=t_1.
	//   11. A request is received, the system measures 1 request.
	//   12. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_1 to
	//      t_0+1 with a value of 1.
	//
	// Note that the first value in a sequence of CUMULATIVE metrics
	// after a reset is equivalent in value to a DELTA metric for the
	// period since the reset.  Although a CUMULATIVE metric could
	// technically be reset after every collection event and still be
	// described as CUMULATIVE, exporters should use DELTA if there is
	// no intention of repeating the StartTimeUnixNano timestamp.
	MetricDescriptor_CUMULATIVE MetricDescriptor_KindElement = 3
	// GROUPING structure means the value has been computed by
	// combining individual values through a meaningful aggregation.
	// GROUPING structure implies the sum of measurements is not
	// necessarily meaningful.  These may be expressed as Histogram or
	// Summary data points for DELTA kind and CUMULATIVE temporality
	// kinds.  These may also be expressed as INSTANTANEOUS kind when
	// reporting a scalar value type (e.g., for LastValue
	// aggregation).  TODO(#159) or raw value (i.e., no aggregation).
	MetricDescriptor_GROUPING MetricDescriptor_KindElement = 4
	// ADDING structure means the measurement determines a sum.  For
	// DELTA kind this is expressed as the change in sum since the
	// last collection.  For CUMULATIVE kind this is expressed as the
	// last collected value of the sum.  For INSTANTANEOUS kind this
	// is expressed as a scalar value that would be added into a Sum.
	MetricDescriptor_ADDING MetricDescriptor_KindElement = 8
	// ADDING_MONOTONIC has ADDING structure with a guaranteed
	// monotonic sum.  ADDING_MONOTONIC indicates that the calculated
	// sum is non-decreasing, therefore can be monitored as a
	// non-negative rate of change.
	MetricDescriptor_ADDING_MONOTONIC MetricDescriptor_KindElement = 12
	// SNAPSHOT may be set for any kind of metric, indicating it
	// was generated through a callback invoked deliberately by the
	// SDK.  In SNAPSHOT measurements, TimeUnixNano values depend
	// on the SDK's decision to collect, not the application.
	//
	// When SNAPSHOT is not set, it implies the event originated from
	// the application calling the SDK with a measurement with a
	// context.  These events are CONTINUOUS measurements, in that
	// case.
	MetricDescriptor_SNAPSHOT MetricDescriptor_KindElement = 16
)

var MetricDescriptor_KindElement_name = map[int32]string{
	0:  "INVALID_KIND_ELEMENT",
	1:  "INSTANTANEOUS",
	2:  "DELTA",
	3:  "CUMULATIVE",
	4:  "GROUPING",
	8:  "ADDING",
	12: "ADDING_MONOTONIC",
	16: "SNAPSHOT",
}

var MetricDescriptor_KindElement_value = map[string]int32{
	"INVALID_KIND_ELEMENT": 0,
	"INSTANTANEOUS":        1,
	"DELTA":                2,
	"CUMULATIVE":           3,
	"GROUPING":             4,
	"ADDING":               8,
	"ADDING_MONOTONIC":     12,
	"SNAPSHOT":             16,
}

func (x MetricDescriptor_KindElement) String() string {
	return proto.EnumName(MetricDescriptor_KindElement_name, int32(x))
}

func (MetricDescriptor_KindElement) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 1}
}

// Kind explains how the DataPoint was produced (called
// "Structure"), how the point was aggregated with resepect to time
// (called "Temporality"), whether it was computed by a snapshot,
// and (when the Structure is ADDING) whether the sum is not
// monotonic.
//
// Kind names are generated from valid combinations of KindElement
// by joining the effective KindElements using underscores.  There
// are:
//
// - 3 possibilities for Temporality
// - 3 possibilities for Structure:
// - 2 possibilities of being a Snapshot or not (i.e., Continuous).
//
// Excluding the snapshot instantaneous combinations, this makes
// 15 valid values.
//
// The cases are detailed below in terms of:
//
// - How StartTimeUnixNano and TimeUnixNano are interpreted?
// - Which OpenTelemetry is likely to produce instrument?
// - Under which typical aggregations?
// - Producing which kind of data point?
//
// Certain general statements can be made.
//
// About the three Structure kinds:
//
// 1. ADDING_MONOTONIC kinds associate with Counter and SumObserver
// 2. ADDING kinds associate with UpDownCounter and UpDownSumObserver
// 3. GROUPING kinds associate with ValueRecorder and ValueObserver instruments
//
// About SNAPSHOT kinds:
//
// 1. SNAPSHOT kinds associate with Observer instruments
// 2. INSTANTANEOUS temporality does not combine with SNAPSHOT kinds.
//
// About ADDING|INSTANTANEOUS vs ADDING|DELTA:
//
// 1. An ADDING|INSTANTANEOUS event is stateless, has no StartTimeUnixNano.
// 2. An ADDING|DELTA event remembers its start time, sets StartTimeUnixNano.
// 3. Same consideration for ADDING_MONOTONIC instantaneous vs delta.
//
// About SCALAR_INT64 and SCALAR_DOUBLE value type (TODO(#159) and
// equally the RAW value types):
//
// 1. SCALAR value type interpretation depends on both temporality
//    and structure.
// 2. For GROUPING kinds:
//    - For INSTANTANEOUS temporality: An individual measurement
//    - For DELTA or CUMULATIVE temporality: The last measured individual value
//      in the collection interval.
// 3. For ADDING and ADDING_MONOONIC kinds:
//    - For INSTANTANEOUS temporality: An instantaneously measured change in a sum
//    - For DELTA temporality: An aggregated change in a sum
//    - For CUMULATIVE temporality: An aggregated sum.
// 4. INSTANTANEOUS kinds are always scalar values (TODO(#159) or raw).
//
// About CUMULATIVE kinds:
//
// 1. CUMULATIVE GROUPING kinds typically use Histogram data points
// 2. CUMULATIVE is rarely used with Summary data points
type MetricDescriptor_Kind int32

const (
	// INVALID_KIND is the default Kind, it MUST not be used.
	MetricDescriptor_INVALID_KIND MetricDescriptor_Kind = 0
	// ADDING_MONOTONIC_INSTANTANEOUS kind describes the change in a
	// sum as measured at an instant (TimeUnixNano).  The value MUST
	// be non-negative.  Generally this is the value of an
	// OpenTelemetry Counter instrument without aggregation.
	// Typically expressed as a scalar (TODO(#159): or raw) value.
	MetricDescriptor_ADDING_MONOTONIC_INSTANTANEOUS MetricDescriptor_Kind = 13
	// ADDING_MONOTONIC_DELTA describes the change in a sum
	// accumulated since the metric was last collected
	// (StartTimeUnixNano) through the measured time (TimeUnixNano).
	// The value MUST be non-negative.  Generally this is the result
	// of aggregating an OpenTelemetry Counter instrument since the
	// last collection.  Typically expressed as a scalar or histogram
	// value.
	MetricDescriptor_ADDING_MONOTONIC_DELTA MetricDescriptor_Kind = 14
	// ADDING_MONOTONIC_DELTA_SNAPSHOT is ADDING_MONOTONIC_DELTA
	// with snapshot semantics specified by the OpenTelemetry API,
	// indicating the value was collected through a callback.
	// Generally this is the temporal difference between values of an
	// OpenTelemetry SumObserver instrument.  Typically expressed as a
	// scalar or histogram value.
	MetricDescriptor_ADDING_MONOTONIC_DELTA_SNAPSHOT MetricDescriptor_Kind = 30
	// ADDING_MONOTONIC_CUMULATIVE describes the current value of a
	// sum accumulated from the reset time (StartTimeUnixNano) through
	// the measured time (TimeUnixNano).  The value must be
	// non-negative and not less than the previously reported value of
	// the same metric.  Generally this is the result of aggregating an
	// OpenTelemetry Counter instrument since the last reset time.
	// Typically expressed as a scalar or histogram value.
	MetricDescriptor_ADDING_MONOTONIC_CUMULATIVE MetricDescriptor_Kind = 15
	// ADDING_MONOTONIC_CUMULATIVE_SNAPSHOT is
	// ADDING_MONOTONIC_CUMULATIVE with snapshot semantics
	// specified by the OpenTelemetry API, indicating the value was
	// collected through a callback.  Generally this is the sum of
	// measurements of an OpenTelemetry SumObserver instrument.
	// Typically expressed as a scalar or histogram value.
	MetricDescriptor_ADDING_MONOTONIC_CUMULATIVE_SNAPSHOT MetricDescriptor_Kind = 31
	// ADDING_INSTANTANEOUS kind describes the change in a sum as
	// measured at an instant (TimeUnixNano).  The value may be
	// positive or negative.  Generally this is the value of an
	// OpenTelemetry UpDownCounter instrument without aggregation.
	// Typically expressed as a scalar (TODO(#159): or raw) value.
	MetricDescriptor_ADDING_INSTANTANEOUS MetricDescriptor_Kind = 9
	// ADDING_DELTA describes the change in a sum accumulated since
	// the metric was last collected (StartTimeUnixNano) through the
	// measured time (TimeUnixNano).  The value may be positive or
	// negative.  Generally this is the result of aggregating an
	// OpenTelemetry UpDownCounter instrument since the last
	// collection.  Typically expressed as a scalar or histogram
	// value.
	MetricDescriptor_ADDING_DELTA MetricDescriptor_Kind = 10
	// ADDING_DELTA_SNAPSHOT is ADDING_DELTA with snapshot
	// semantics specified by the OpenTelemetry API, indicating the
	// value was collected through a callback.  Generally this is the
	// temporal difference between values of an OpenTelemetry
	// UpDownSumObserver instrument.  Typically expressed as a scalar
	// or histogram value.
	MetricDescriptor_ADDING_DELTA_SNAPSHOT MetricDescriptor_Kind = 26
	// ADDING_CUMULATIVE describes the current value of a sum
	// accumulated from the reset time (StartTimeUnixNano) through the
	// measured time (TimeUnixNano).  The value may be positive or
	// negative.  Generally this is the result of aggregating an
	// OpenTelemetry UpDownCounter instrument since the last reset
	// time.  Typically expressed as a scalar or histogram value.
	MetricDescriptor_ADDING_CUMULATIVE MetricDescriptor_Kind = 11
	// ADDING_CUMULATIVE_SNAPSHOT is ADDING_CUMULATIVE with
	// snapshot semantics specified by the OpenTelemetry API,
	// indicating the value was collected through a callback.
	// Generally this is the sum of measurements of an OpenTelemetry
	// UpDownSumObserver instrument.  Typically expressed as a scalar
	// or histogram value.
	MetricDescriptor_ADDING_CUMULATIVE_SNAPSHOT MetricDescriptor_Kind = 27
	// GROUPING_INSTANTANEOUS kind describes an individual value
	// measured at an instant (TimeUnixNano).  Generally this is the value of an
	// OpenTelemetry ValueRecorder instrument without aggregation.
	// Typically expressed as a scalar (TODO(#159): or raw) value.
	MetricDescriptor_GROUPING_INSTANTANEOUS MetricDescriptor_Kind = 5
	// GROUPING_DELTA kind describes a set of individual values
	// measured from the most recent collection (StartTimeUnixNano)
	// through the measured time (TimeUnixNano).  Generally this is
	// the aggregated value of an OpenTelemetry ValueRecorder
	// instrument.  Typically expressed as a scalar, histogram, or
	// summary value.  When expressed as a scalar value, this is
	// specified to mean the most recent (i.e., "last") value to occur
	// within the collection interval.
	MetricDescriptor_GROUPING_DELTA MetricDescriptor_Kind = 6
	// GROUPING_DELTA_SNAPSHOT is GROUPING_DELTA with snapshot
	// semantics specified by the OpenTelemetry API, indicating the
	// value was collected through a callback.  Generally this is the
	// aggregated value of an OpenTelemetry ValueObserver instrument.
	// Typically expressed as a scalar, histogram, or summary value.
	MetricDescriptor_GROUPING_DELTA_SNAPSHOT MetricDescriptor_Kind = 22
	// GROUPING_CUMULATIVE kind describes a set of individual values
	// measured from the last reset time (StartTimeUnixNano) through
	// the measured time (TimeUnixNano).  Generally this is the
	// aggregated value of an OpenTelemetry ValueRecorder instrument.
	// Typically expressed as a scalar or histogram value.  When
	// expressed as a scalar value, this is specified to mean the most
	// recent (i.e., "last") value to occur since the reset time,
	// which may have occurred prior to the most recent collection
	// interval.
	MetricDescriptor_GROUPING_CUMULATIVE MetricDescriptor_Kind = 7
	// GROUPING_CUMULATIVE_SNAPSHOT is GROUPING_CUMULATIVE with
	// snapshot semantics specified by the OpenTelemetry API,
	// indicating the value was collected through a callback.
	// Generally this is the aggregated value of an OpenTelemetry
	// ValueObserver instrument.  Typically expressed as a scalar or
	// histogram value.
	MetricDescriptor_GROUPING_CUMULATIVE_SNAPSHOT MetricDescriptor_Kind = 23
)

var MetricDescriptor_Kind_name = map[int32]string{
	0:  "INVALID_KIND",
	13: "ADDING_MONOTONIC_INSTANTANEOUS",
	14: "ADDING_MONOTONIC_DELTA",
	30: "ADDING_MONOTONIC_DELTA_SNAPSHOT",
	15: "ADDING_MONOTONIC_CUMULATIVE",
	31: "ADDING_MONOTONIC_CUMULATIVE_SNAPSHOT",
	9:  "ADDING_INSTANTANEOUS",
	10: "ADDING_DELTA",
	26: "ADDING_DELTA_SNAPSHOT",
	11: "ADDING_CUMULATIVE",
	27: "ADDING_CUMULATIVE_SNAPSHOT",
	5:  "GROUPING_INSTANTANEOUS",
	6:  "GROUPING_DELTA",
	22: "GROUPING_DELTA_SNAPSHOT",
	7:  "GROUPING_CUMULATIVE",
	23: "GROUPING_CUMULATIVE_SNAPSHOT",
}

var MetricDescriptor_Kind_value = map[string]int32{
	"INVALID_KIND":                         0,
	"ADDING_MONOTONIC_INSTANTANEOUS":       13,
	"ADDING_MONOTONIC_DELTA":               14,
	"ADDING_MONOTONIC_DELTA_SNAPSHOT":      30,
	"ADDING_MONOTONIC_CUMULATIVE":          15,
	"ADDING_MONOTONIC_CUMULATIVE_SNAPSHOT": 31,
	"ADDING_INSTANTANEOUS":                 9,
	"ADDING_DELTA":                         10,
	"ADDING_DELTA_SNAPSHOT":                26,
	"ADDING_CUMULATIVE":                    11,
	"ADDING_CUMULATIVE_SNAPSHOT":           27,
	"GROUPING_INSTANTANEOUS":               5,
	"GROUPING_DELTA":                       6,
	"GROUPING_DELTA_SNAPSHOT":              22,
	"GROUPING_CUMULATIVE":                  7,
	"GROUPING_CUMULATIVE_SNAPSHOT":         23,
}

func (x MetricDescriptor_Kind) String() string {
	return proto.EnumName(MetricDescriptor_Kind_name, int32(x))
}

func (MetricDescriptor_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 2}
}

// A collection of InstrumentationLibraryMetrics from a Resource.
type ResourceMetrics struct {
	// The resource for the metrics in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of metrics that originate from a resource.
	InstrumentationLibraryMetrics []*InstrumentationLibraryMetrics `protobuf:"bytes,2,rep,name=instrumentation_library_metrics,json=instrumentationLibraryMetrics,proto3" json:"instrumentation_library_metrics,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                         `json:"-"`
	XXX_unrecognized              []byte                           `json:"-"`
	XXX_sizecache                 int32                            `json:"-"`
}

func (m *ResourceMetrics) Reset()         { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()    {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{0}
}

func (m *ResourceMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceMetrics.Unmarshal(m, b)
}
func (m *ResourceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceMetrics.Marshal(b, m, deterministic)
}
func (m *ResourceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMetrics.Merge(m, src)
}
func (m *ResourceMetrics) XXX_Size() int {
	return xxx_messageInfo_ResourceMetrics.Size(m)
}
func (m *ResourceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMetrics proto.InternalMessageInfo

func (m *ResourceMetrics) GetResource() *v1.Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceMetrics) GetInstrumentationLibraryMetrics() []*InstrumentationLibraryMetrics {
	if m != nil {
		return m.InstrumentationLibraryMetrics
	}
	return nil
}

// A collection of Metrics produced by an InstrumentationLibrary.
type InstrumentationLibraryMetrics struct {
	// The instrumentation library information for the metrics in this message.
	// If this field is not set then no library info is known.
	InstrumentationLibrary *v11.InstrumentationLibrary `protobuf:"bytes,1,opt,name=instrumentation_library,json=instrumentationLibrary,proto3" json:"instrumentation_library,omitempty"`
	// A list of metrics that originate from an instrumentation library.
	Metrics              []*Metric `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstrumentationLibraryMetrics) Reset()         { *m = InstrumentationLibraryMetrics{} }
func (m *InstrumentationLibraryMetrics) String() string { return proto.CompactTextString(m) }
func (*InstrumentationLibraryMetrics) ProtoMessage()    {}
func (*InstrumentationLibraryMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{1}
}

func (m *InstrumentationLibraryMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Unmarshal(m, b)
}
func (m *InstrumentationLibraryMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Marshal(b, m, deterministic)
}
func (m *InstrumentationLibraryMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstrumentationLibraryMetrics.Merge(m, src)
}
func (m *InstrumentationLibraryMetrics) XXX_Size() int {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Size(m)
}
func (m *InstrumentationLibraryMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_InstrumentationLibraryMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_InstrumentationLibraryMetrics proto.InternalMessageInfo

func (m *InstrumentationLibraryMetrics) GetInstrumentationLibrary() *v11.InstrumentationLibrary {
	if m != nil {
		return m.InstrumentationLibrary
	}
	return nil
}

func (m *InstrumentationLibraryMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Metric contains one or more timeseries.
//
// The data model and relation between entities is shown in the
// diagram below.  Here, "DataPoint" is the term used to refer to any
// one of the specific data point kinds, and "points" is the term use
// to refer to any one of the lists of points contained in the Metric.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a name, description, unit, kind, and value type.
// - Points is a list of DataPoints (shown vertically).
// - DataPoint contains timestamps, labels, and one of the value type fields.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         | name                   |
//  |          |         | description            |
//  |          |         | unit                   |
//  |    points|--+      | kind                   |
//  +----------+  |      | value type             |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
// All DataPoint types have includes three common fields:
// - Labels are the optional key-value pairs associated with the data point.
// - StartTimeUnixNano MUST be set to the start of the interval when the
//   descriptor kind includes CUMULATIVE or DELTA.  This field is not set
//   for INSTANTANEOUS timeseries, where instead the TimeUnixNano field is
//   set for individual points.
// - TimeUnixNano MUST be set to:
//   - the end of the interval (CUMULATIVE or DELTA)
//   - the instantaneous time of the event (INSTANTANEOUS).
//
// The ValueType of the descriptor determines which of the repeated
// points fields is used.
type Metric struct {
	// Descriptor describes the Metric.
	//
	// N.B. "Descriptor" is a reserved term in protobuf, protoc
	// generates a field named "Descriptor_" thus we use
	// "metric_descriptor".
	MetricDescriptor *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor,proto3" json:"metric_descriptor,omitempty"`
	// Data is a list of one or more DataPoints for a single metric. Only one of the
	// following fields is used for the data, depending on the type of the metric defined
	// by MetricDescriptor.type field.
	Int64DataPoints      []*Int64DataPoint     `protobuf:"bytes,2,rep,name=int64_data_points,json=int64DataPoints,proto3" json:"int64_data_points,omitempty"`
	DoubleDataPoints     []*DoubleDataPoint    `protobuf:"bytes,3,rep,name=double_data_points,json=doubleDataPoints,proto3" json:"double_data_points,omitempty"`
	HistogramDataPoints  []*HistogramDataPoint `protobuf:"bytes,4,rep,name=histogram_data_points,json=histogramDataPoints,proto3" json:"histogram_data_points,omitempty"`
	SummaryDataPoints    []*SummaryDataPoint   `protobuf:"bytes,5,rep,name=summary_data_points,json=summaryDataPoints,proto3" json:"summary_data_points,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetInt64DataPoints() []*Int64DataPoint {
	if m != nil {
		return m.Int64DataPoints
	}
	return nil
}

func (m *Metric) GetDoubleDataPoints() []*DoubleDataPoint {
	if m != nil {
		return m.DoubleDataPoints
	}
	return nil
}

func (m *Metric) GetHistogramDataPoints() []*HistogramDataPoint {
	if m != nil {
		return m.HistogramDataPoints
	}
	return nil
}

func (m *Metric) GetSummaryDataPoints() []*SummaryDataPoint {
	if m != nil {
		return m.SummaryDataPoints
	}
	return nil
}

// Defines a metric type and its schema.
type MetricDescriptor struct {
	// Name of the metric, including its DNS name prefix. It must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the metric, which can be used in documentation.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// ValueType is the type of values this metric has.
	ValueType MetricDescriptor_ValueType `protobuf:"varint,4,opt,name=value_type,json=valueType,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_ValueType" json:"value_type,omitempty"`
	// Kind describes properties of the Metric that are necessary to
	// interpret the data and/or describe how it was produced.
	Kind                 MetricDescriptor_Kind `protobuf:"varint,5,opt,name=kind,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Kind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetricDescriptor) Reset()         { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()    {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3}
}

func (m *MetricDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricDescriptor.Unmarshal(m, b)
}
func (m *MetricDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricDescriptor.Marshal(b, m, deterministic)
}
func (m *MetricDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDescriptor.Merge(m, src)
}
func (m *MetricDescriptor) XXX_Size() int {
	return xxx_messageInfo_MetricDescriptor.Size(m)
}
func (m *MetricDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDescriptor proto.InternalMessageInfo

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetValueType() MetricDescriptor_ValueType {
	if m != nil {
		return m.ValueType
	}
	return MetricDescriptor_INVALID_VALUE_TYPE
}

func (m *MetricDescriptor) GetKind() MetricDescriptor_Kind {
	if m != nil {
		return m.Kind
	}
	return MetricDescriptor_INVALID_KIND
}

// Int64DataPoint is a single data point in a timeseries that describes the time-varying
// values of a int64 metric.
type Int64DataPoint struct {
	// The set of labels that uniquely identify this timeseries.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the time when the cumulative value was reset to zero.
	// This is used for Counter type only. For Gauge the value is not specified and
	// defaults to 0.
	//
	// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
	// may be decided by the backend.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the moment when this value was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// value itself.
	Value                int64    `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Int64DataPoint) Reset()         { *m = Int64DataPoint{} }
func (m *Int64DataPoint) String() string { return proto.CompactTextString(m) }
func (*Int64DataPoint) ProtoMessage()    {}
func (*Int64DataPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4}
}

func (m *Int64DataPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Int64DataPoint.Unmarshal(m, b)
}
func (m *Int64DataPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Int64DataPoint.Marshal(b, m, deterministic)
}
func (m *Int64DataPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int64DataPoint.Merge(m, src)
}
func (m *Int64DataPoint) XXX_Size() int {
	return xxx_messageInfo_Int64DataPoint.Size(m)
}
func (m *Int64DataPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Int64DataPoint.DiscardUnknown(m)
}

var xxx_messageInfo_Int64DataPoint proto.InternalMessageInfo

func (m *Int64DataPoint) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Int64DataPoint) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Int64DataPoint) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *Int64DataPoint) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// DoubleDataPoint is a single data point in a timeseries that describes the time-varying
// value of a double metric.
type DoubleDataPoint struct {
	// The set of labels that uniquely identify this timeseries.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the time when the cumulative value was reset to zero.
	// This is used for Counter type only. For Gauge the value is not specified and
	// defaults to 0.
	//
	// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
	// may be decided by the backend.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the moment when this value was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// value itself.
	Value                float64  `protobuf:"fixed64,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DoubleDataPoint) Reset()         { *m = DoubleDataPoint{} }
func (m *DoubleDataPoint) String() string { return proto.CompactTextString(m) }
func (*DoubleDataPoint) ProtoMessage()    {}
func (*DoubleDataPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{5}
}

func (m *DoubleDataPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DoubleDataPoint.Unmarshal(m, b)
}
func (m *DoubleDataPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DoubleDataPoint.Marshal(b, m, deterministic)
}
func (m *DoubleDataPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleDataPoint.Merge(m, src)
}
func (m *DoubleDataPoint) XXX_Size() int {
	return xxx_messageInfo_DoubleDataPoint.Size(m)
}
func (m *DoubleDataPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleDataPoint.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleDataPoint proto.InternalMessageInfo

func (m *DoubleDataPoint) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *DoubleDataPoint) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *DoubleDataPoint) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *DoubleDataPoint) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// HistogramDataPoint is a single data point in a timeseries that describes the time-varying
// values of a Histogram. A Histogram contains summary statistics for a population of values,
// it may optionally contain the distribution of those values across a set of buckets.
type HistogramDataPoint struct {
	// The set of labels that uniquely identify this timeseries.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the time when the cumulative value was reset to zero.
	//
	// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
	// may be decided by the backend.
	// Note: this field is always unspecified and ignored if MetricDescriptor.type==GAUGE_HISTOGRAM.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the moment when this value was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// count is the number of values in the population. Must be non-negative. This value
	// must be equal to the sum of the "count" fields in buckets if a histogram is provided.
	Count uint64 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	// sum of the values in the population. If count is zero then this field
	// must be zero. This value must be equal to the sum of the "sum" fields in buckets if
	// a histogram is provided.
	Sum float64 `protobuf:"fixed64,5,opt,name=sum,proto3" json:"sum,omitempty"`
	// buckets is an optional field contains the values of histogram for each bucket.
	//
	// The sum of the values in the buckets "count" field must equal the value in the count field.
	//
	// The number of elements in buckets array must be by one greater than the
	// number of elements in bucket_bounds array.
	//
	// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
	// must also be present and number of elements in this field must be equal to the
	// number of buckets defined by bucket_options.
	Buckets []*HistogramDataPoint_Bucket `protobuf:"bytes,6,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// explicit_bounds specifies buckets with explicitly defined bounds for values.
	// The bucket boundaries are described by "bounds" field.
	//
	// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
	// at index i are:
	//
	// [0, bounds[i]) for i == 0
	// [bounds[i-1], bounds[i]) for 0 < i < N-1
	// [bounds[i], +infinity) for i == N-1
	// The values in bounds array must be strictly increasing and > 0.
	//
	// Note: only [a, b) intervals are currently supported for each bucket. If we decides
	// to also support (a, b] intervals we should add support for these by defining a boolean
	// value which decides what type of intervals to use.
	ExplicitBounds       []float64 `protobuf:"fixed64,7,rep,packed,name=explicit_bounds,json=explicitBounds,proto3" json:"explicit_bounds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *HistogramDataPoint) Reset()         { *m = HistogramDataPoint{} }
func (m *HistogramDataPoint) String() string { return proto.CompactTextString(m) }
func (*HistogramDataPoint) ProtoMessage()    {}
func (*HistogramDataPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{6}
}

func (m *HistogramDataPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HistogramDataPoint.Unmarshal(m, b)
}
func (m *HistogramDataPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HistogramDataPoint.Marshal(b, m, deterministic)
}
func (m *HistogramDataPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramDataPoint.Merge(m, src)
}
func (m *HistogramDataPoint) XXX_Size() int {
	return xxx_messageInfo_HistogramDataPoint.Size(m)
}
func (m *HistogramDataPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramDataPoint.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramDataPoint proto.InternalMessageInfo

func (m *HistogramDataPoint) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *HistogramDataPoint) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *HistogramDataPoint) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *HistogramDataPoint) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *HistogramDataPoint) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *HistogramDataPoint) GetBuckets() []*HistogramDataPoint_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *HistogramDataPoint) GetExplicitBounds() []float64 {
	if m != nil {
		return m.ExplicitBounds
	}
	return nil
}

// Bucket contains values for a bucket.
type HistogramDataPoint_Bucket struct {
	// The number of values in each bucket of the histogram, as described by
	// bucket_options.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// exemplar is an optional representative value of the bucket.
	Exemplar             *HistogramDataPoint_Bucket_Exemplar `protobuf:"bytes,2,opt,name=exemplar,proto3" json:"exemplar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *HistogramDataPoint_Bucket) Reset()         { *m = HistogramDataPoint_Bucket{} }
func (m *HistogramDataPoint_Bucket) String() string { return proto.CompactTextString(m) }
func (*HistogramDataPoint_Bucket) ProtoMessage()    {}
func (*HistogramDataPoint_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{6, 0}
}

func (m *HistogramDataPoint_Bucket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HistogramDataPoint_Bucket.Unmarshal(m, b)
}
func (m *HistogramDataPoint_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HistogramDataPoint_Bucket.Marshal(b, m, deterministic)
}
func (m *HistogramDataPoint_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramDataPoint_Bucket.Merge(m, src)
}
func (m *HistogramDataPoint_Bucket) XXX_Size() int {
	return xxx_messageInfo_HistogramDataPoint_Bucket.Size(m)
}
func (m *HistogramDataPoint_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramDataPoint_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramDataPoint_Bucket proto.InternalMessageInfo

func (m *HistogramDataPoint_Bucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *HistogramDataPoint_Bucket) GetExemplar() *HistogramDataPoint_Bucket_Exemplar {
	if m != nil {
		return m.Exemplar
	}
	return nil
}

// Exemplars are example points that may be used to annotate aggregated
// Histogram values. They are metadata that gives information about a
// particular value added to a Histogram bucket.
type HistogramDataPoint_Bucket_Exemplar struct {
	// Value of the exemplar point. It determines which bucket the exemplar belongs to.
	// If bucket_options define bounds for this bucket then this value must be within
	// the defined bounds.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// time_unix_nano is the moment when this exemplar was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// exemplar_attachments are contextual information about the example value.
	// Keys in this list must be unique.
	Attachments          []*v11.StringKeyValue `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *HistogramDataPoint_Bucket_Exemplar) Reset()         { *m = HistogramDataPoint_Bucket_Exemplar{} }
func (m *HistogramDataPoint_Bucket_Exemplar) String() string { return proto.CompactTextString(m) }
func (*HistogramDataPoint_Bucket_Exemplar) ProtoMessage()    {}
func (*HistogramDataPoint_Bucket_Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{6, 0, 0}
}

func (m *HistogramDataPoint_Bucket_Exemplar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar.Unmarshal(m, b)
}
func (m *HistogramDataPoint_Bucket_Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar.Marshal(b, m, deterministic)
}
func (m *HistogramDataPoint_Bucket_Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar.Merge(m, src)
}
func (m *HistogramDataPoint_Bucket_Exemplar) XXX_Size() int {
	return xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar.Size(m)
}
func (m *HistogramDataPoint_Bucket_Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramDataPoint_Bucket_Exemplar proto.InternalMessageInfo

func (m *HistogramDataPoint_Bucket_Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *HistogramDataPoint_Bucket_Exemplar) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *HistogramDataPoint_Bucket_Exemplar) GetAttachments() []*v11.StringKeyValue {
	if m != nil {
		return m.Attachments
	}
	return nil
}

// SummaryDataPoint is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
type SummaryDataPoint struct {
	// The set of labels that uniquely identify this timeseries.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the time when the cumulative value was reset to zero.
	//
	// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
	// may be decided by the backend.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the moment when this value was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// The total number of recorded values since start_time. Optional since
	// some systems don't expose this.
	Count uint64 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	// The total sum of recorded values since start_time. Optional since some
	// systems don't expose this. If count is zero then this field must be zero.
	Sum float64 `protobuf:"fixed64,5,opt,name=sum,proto3" json:"sum,omitempty"`
	// A list of values at different percentiles of the distribution calculated
	// from the current snapshot. The percentiles must be strictly increasing.
	PercentileValues     []*SummaryDataPoint_ValueAtPercentile `protobuf:"bytes,6,rep,name=percentile_values,json=percentileValues,proto3" json:"percentile_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *SummaryDataPoint) Reset()         { *m = SummaryDataPoint{} }
func (m *SummaryDataPoint) String() string { return proto.CompactTextString(m) }
func (*SummaryDataPoint) ProtoMessage()    {}
func (*SummaryDataPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{7}
}

func (m *SummaryDataPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SummaryDataPoint.Unmarshal(m, b)
}
func (m *SummaryDataPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SummaryDataPoint.Marshal(b, m, deterministic)
}
func (m *SummaryDataPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummaryDataPoint.Merge(m, src)
}
func (m *SummaryDataPoint) XXX_Size() int {
	return xxx_messageInfo_SummaryDataPoint.Size(m)
}
func (m *SummaryDataPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_SummaryDataPoint.DiscardUnknown(m)
}

var xxx_messageInfo_SummaryDataPoint proto.InternalMessageInfo

func (m *SummaryDataPoint) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *SummaryDataPoint) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *SummaryDataPoint) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *SummaryDataPoint) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SummaryDataPoint) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *SummaryDataPoint) GetPercentileValues() []*SummaryDataPoint_ValueAtPercentile {
	if m != nil {
		return m.PercentileValues
	}
	return nil
}

// Represents the value at a given percentile of a distribution.
//
// To record Min and Max values following conventions are used:
// - The 100th percentile is equivalent to the maximum value observed.
// - The 0th percentile is equivalent to the minimum value observed.
//
// See the following issue for more context:
// https://github.com/open-telemetry/opentelemetry-proto/issues/125
type SummaryDataPoint_ValueAtPercentile struct {
	// The percentile of a distribution. Must be in the interval
	// [0.0, 100.0].
	Percentile float64 `protobuf:"fixed64,1,opt,name=percentile,proto3" json:"percentile,omitempty"`
	// The value at the given percentile of a distribution.
	Value                float64  `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SummaryDataPoint_ValueAtPercentile) Reset()         { *m = SummaryDataPoint_ValueAtPercentile{} }
func (m *SummaryDataPoint_ValueAtPercentile) String() string { return proto.CompactTextString(m) }
func (*SummaryDataPoint_ValueAtPercentile) ProtoMessage()    {}
func (*SummaryDataPoint_ValueAtPercentile) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{7, 0}
}

func (m *SummaryDataPoint_ValueAtPercentile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SummaryDataPoint_ValueAtPercentile.Unmarshal(m, b)
}
func (m *SummaryDataPoint_ValueAtPercentile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SummaryDataPoint_ValueAtPercentile.Marshal(b, m, deterministic)
}
func (m *SummaryDataPoint_ValueAtPercentile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummaryDataPoint_ValueAtPercentile.Merge(m, src)
}
func (m *SummaryDataPoint_ValueAtPercentile) XXX_Size() int {
	return xxx_messageInfo_SummaryDataPoint_ValueAtPercentile.Size(m)
}
func (m *SummaryDataPoint_ValueAtPercentile) XXX_DiscardUnknown() {
	xxx_messageInfo_SummaryDataPoint_ValueAtPercentile.DiscardUnknown(m)
}

var xxx_messageInfo_SummaryDataPoint_ValueAtPercentile proto.InternalMessageInfo

func (m *SummaryDataPoint_ValueAtPercentile) GetPercentile() float64 {
	if m != nil {
		return m.Percentile
	}
	return 0
}

func (m *SummaryDataPoint_ValueAtPercentile) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_ValueType", MetricDescriptor_ValueType_name, MetricDescriptor_ValueType_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_KindElement", MetricDescriptor_KindElement_name, MetricDescriptor_KindElement_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Kind", MetricDescriptor_Kind_name, MetricDescriptor_Kind_value)
	proto.RegisterType((*ResourceMetrics)(nil), "opentelemetry.proto.metrics.v1.ResourceMetrics")
	proto.RegisterType((*InstrumentationLibraryMetrics)(nil), "opentelemetry.proto.metrics.v1.InstrumentationLibraryMetrics")
	proto.RegisterType((*Metric)(nil), "opentelemetry.proto.metrics.v1.Metric")
	proto.RegisterType((*MetricDescriptor)(nil), "opentelemetry.proto.metrics.v1.MetricDescriptor")
	proto.RegisterType((*Int64DataPoint)(nil), "opentelemetry.proto.metrics.v1.Int64DataPoint")
	proto.RegisterType((*DoubleDataPoint)(nil), "opentelemetry.proto.metrics.v1.DoubleDataPoint")
	proto.RegisterType((*HistogramDataPoint)(nil), "opentelemetry.proto.metrics.v1.HistogramDataPoint")
	proto.RegisterType((*HistogramDataPoint_Bucket)(nil), "opentelemetry.proto.metrics.v1.HistogramDataPoint.Bucket")
	proto.RegisterType((*HistogramDataPoint_Bucket_Exemplar)(nil), "opentelemetry.proto.metrics.v1.HistogramDataPoint.Bucket.Exemplar")
	proto.RegisterType((*SummaryDataPoint)(nil), "opentelemetry.proto.metrics.v1.SummaryDataPoint")
	proto.RegisterType((*SummaryDataPoint_ValueAtPercentile)(nil), "opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtPercentile")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/metrics/v1/metrics.proto", fileDescriptor_3c3112f9fa006917)
}

var fileDescriptor_3c3112f9fa006917 = []byte{
	// 1192 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xef, 0x6e, 0xdb, 0x54,
	0x14, 0x9f, 0x93, 0x34, 0x6d, 0x4f, 0xba, 0xd4, 0x39, 0xeb, 0xda, 0x90, 0xb1, 0xb6, 0x84, 0x09,
	0x0a, 0x62, 0x09, 0x2b, 0xdb, 0x24, 0x90, 0x10, 0x38, 0x8b, 0xb5, 0x45, 0xcb, 0x3f, 0x39, 0x49,
	0xa5, 0x4d, 0x1a, 0xc6, 0x49, 0x2e, 0xed, 0xd5, 0xe2, 0xeb, 0xc8, 0xbe, 0xae, 0xda, 0x07, 0xe0,
	0x09, 0x40, 0x82, 0x07, 0x82, 0xaf, 0x20, 0xde, 0x80, 0x07, 0xe0, 0x1b, 0x2f, 0x80, 0x7c, 0x6d,
	0xc7, 0x76, 0x92, 0x35, 0x94, 0x4f, 0xc0, 0xb7, 0xe3, 0xdf, 0x39, 0xe7, 0x77, 0x7e, 0xe7, 0xdc,
	0xeb, 0x6b, 0x5f, 0xf8, 0xc8, 0x9a, 0x12, 0xc6, 0xc9, 0x84, 0x98, 0x84, 0xdb, 0x97, 0xd5, 0xa9,
	0x6d, 0x71, 0xab, 0xea, 0xd9, 0x74, 0xe4, 0x54, 0xcf, 0x1f, 0x84, 0x66, 0x45, 0x38, 0x70, 0x3f,
	0x11, 0xed, 0x83, 0x95, 0x30, 0xe4, 0xfc, 0x41, 0xe9, 0xc3, 0x65, 0x6c, 0x23, 0xcb, 0x34, 0x2d,
	0xe6, 0x91, 0xf9, 0x96, 0x9f, 0x56, 0xaa, 0x2c, 0x8b, 0xb5, 0x89, 0x63, 0xb9, 0xf6, 0x88, 0x78,
	0xd1, 0xa1, 0xed, 0xc7, 0x97, 0x7f, 0x97, 0x60, 0x5b, 0x0b, 0xa0, 0x96, 0x5f, 0x12, 0x55, 0xd8,
	0x08, 0xa3, 0x8a, 0xd2, 0xa1, 0x74, 0x94, 0x3b, 0xfe, 0xa0, 0xb2, 0x4c, 0xe2, 0x8c, 0xea, 0xfc,
	0x41, 0x25, 0xe4, 0xd0, 0x66, 0xa9, 0xf8, 0xad, 0x04, 0x07, 0x94, 0x39, 0xdc, 0x76, 0x4d, 0xc2,
	0xb8, 0xc1, 0xa9, 0xc5, 0xf4, 0x09, 0x1d, 0xda, 0x86, 0x7d, 0xa9, 0x07, 0xdd, 0x15, 0x53, 0x87,
	0xe9, 0xa3, 0xdc, 0xf1, 0xe7, 0x95, 0xab, 0x27, 0x50, 0x69, 0x24, 0x69, 0x9a, 0x3e, 0x4b, 0xa0,
	0x57, 0xbb, 0x4b, 0xaf, 0x72, 0x97, 0x7f, 0x93, 0xe0, 0xee, 0x95, 0x04, 0xc8, 0x60, 0xef, 0x0d,
	0x42, 0x83, 0xfe, 0x1f, 0x2d, 0x15, 0x18, 0x0c, 0xfe, 0x8d, 0xfa, 0xb4, 0xdd, 0xe5, 0xc2, 0xf0,
	0x4b, 0x58, 0x4f, 0x0e, 0xe0, 0xbd, 0x55, 0x03, 0xf0, 0x95, 0x6a, 0x61, 0x5a, 0xf9, 0x8f, 0x34,
	0x64, 0x7d, 0x0c, 0x5f, 0x41, 0xc1, 0x47, 0xf5, 0x31, 0x71, 0x46, 0x36, 0x9d, 0x72, 0xcb, 0x0e,
	0x64, 0x7f, 0xfc, 0xf7, 0x68, 0xeb, 0xb3, 0x3c, 0x4d, 0x36, 0xe7, 0x10, 0x7c, 0x09, 0x05, 0xca,
	0xf8, 0xe3, 0x87, 0xfa, 0xd8, 0xe0, 0x86, 0x3e, 0xb5, 0x28, 0xe3, 0xa1, 0xea, 0xca, 0xea, 0x65,
	0xe3, 0x8f, 0x1f, 0xd6, 0x0d, 0x6e, 0x74, 0xbd, 0x34, 0x6d, 0x9b, 0x26, 0x9e, 0x1d, 0x7c, 0x05,
	0x38, 0xb6, 0xdc, 0xe1, 0x84, 0x24, 0xc8, 0xd3, 0x82, 0xbc, 0xba, 0x8a, 0xbc, 0x2e, 0x32, 0x23,
	0x76, 0x79, 0x9c, 0x04, 0x1c, 0xfc, 0x06, 0x6e, 0x9f, 0x51, 0x87, 0x5b, 0xa7, 0xb6, 0x61, 0x26,
	0x2a, 0x64, 0x44, 0x85, 0xe3, 0x55, 0x15, 0x9e, 0x85, 0xc9, 0x51, 0x91, 0x5b, 0x67, 0x0b, 0x98,
	0x83, 0x5f, 0xc3, 0x2d, 0xc7, 0x35, 0x4d, 0x6f, 0x5f, 0xc7, 0xab, 0xac, 0x89, 0x2a, 0x2b, 0xd7,
	0xa0, 0xe7, 0xa7, 0x46, 0x35, 0x0a, 0xce, 0x1c, 0xe2, 0x94, 0x7f, 0x5d, 0x07, 0x79, 0x7e, 0xad,
	0x10, 0x21, 0xc3, 0x0c, 0xd3, 0x7f, 0x45, 0x37, 0x35, 0x61, 0xe3, 0x21, 0xe4, 0xc2, 0x5d, 0x40,
	0x2d, 0x56, 0x4c, 0x09, 0x57, 0x1c, 0xf2, 0xb2, 0x5c, 0x46, 0x79, 0x31, 0xed, 0x67, 0x79, 0x36,
	0xbe, 0x00, 0x38, 0x37, 0x26, 0x2e, 0xd1, 0xf9, 0xe5, 0x94, 0x14, 0x33, 0x87, 0xd2, 0x51, 0xfe,
	0xf8, 0xb3, 0xeb, 0xee, 0x9d, 0xca, 0x89, 0x47, 0xd1, 0xbf, 0x9c, 0x12, 0x6d, 0xf3, 0x3c, 0x34,
	0xb1, 0x01, 0x99, 0xd7, 0x94, 0x8d, 0x8b, 0x6b, 0x82, 0xf4, 0xd1, 0xb5, 0x49, 0x9f, 0x53, 0x36,
	0xd6, 0x04, 0x45, 0x79, 0x0c, 0x9b, 0xb3, 0x12, 0xb8, 0x0b, 0xd8, 0x68, 0x9f, 0x28, 0xcd, 0x46,
	0x5d, 0x3f, 0x51, 0x9a, 0x03, 0x55, 0xef, 0xbf, 0xe8, 0xaa, 0xf2, 0x0d, 0x94, 0x61, 0xab, 0xf7,
	0x44, 0x69, 0x2a, 0x9a, 0xde, 0x68, 0xf7, 0x1f, 0x3f, 0x94, 0x25, 0x2c, 0xc0, 0xcd, 0x00, 0xa9,
	0x77, 0x06, 0xb5, 0xa6, 0x2a, 0xa7, 0xf0, 0x26, 0x6c, 0x3e, 0x6b, 0xf4, 0xfa, 0x9d, 0xa7, 0x9a,
	0xd2, 0x92, 0xd3, 0x98, 0x83, 0xf5, 0xde, 0xa0, 0xd5, 0x52, 0xb4, 0x17, 0x72, 0xa6, 0xfc, 0x9d,
	0x04, 0x39, 0xaf, 0xa8, 0xea, 0x69, 0x64, 0x1c, 0x8b, 0xb0, 0x13, 0x16, 0x7a, 0xde, 0x68, 0xd7,
	0x75, 0xb5, 0xa9, 0xb6, 0xd4, 0x76, 0x5f, 0xbe, 0xe1, 0x11, 0x37, 0xda, 0xbd, 0xbe, 0xd2, 0xee,
	0x2b, 0x6d, 0xb5, 0x33, 0xe8, 0xc9, 0x12, 0x6e, 0xc2, 0x5a, 0x5d, 0x6d, 0xf6, 0x15, 0x39, 0x85,
	0x79, 0x80, 0x27, 0x83, 0xd6, 0xa0, 0xa9, 0xf4, 0x1b, 0x27, 0xaa, 0x9c, 0xc6, 0x2d, 0xd8, 0x78,
	0xaa, 0x75, 0x06, 0xdd, 0x46, 0xfb, 0xa9, 0x9c, 0x41, 0x80, 0xac, 0x52, 0xaf, 0x7b, 0xf6, 0x06,
	0xee, 0x80, 0xec, 0xdb, 0x7a, 0xab, 0xd3, 0xee, 0xf4, 0x3b, 0xed, 0xc6, 0x13, 0x79, 0xcb, 0x8b,
	0xef, 0xb5, 0x95, 0x6e, 0xef, 0x59, 0xa7, 0x2f, 0xcb, 0xe5, 0x5f, 0xd2, 0x90, 0xf1, 0x54, 0x79,
	0xfd, 0xc5, 0xe5, 0xc8, 0x37, 0xb0, 0x0c, 0xfb, 0xf3, 0xe9, 0x7a, 0x52, 0xd7, 0x4d, 0x2c, 0xc1,
	0xee, 0x42, 0x8c, 0x2f, 0x34, 0x8f, 0xef, 0xc2, 0xc1, 0x72, 0x9f, 0x3e, 0xab, 0xbf, 0x8f, 0x07,
	0x70, 0x67, 0x21, 0x28, 0xd6, 0xde, 0x36, 0x1e, 0xc1, 0xbd, 0x2b, 0x02, 0x22, 0xaa, 0x03, 0x6f,
	0xa0, 0x41, 0x64, 0x52, 0xe5, 0xa6, 0xd7, 0x5b, 0xe0, 0xf1, 0xb5, 0x01, 0xbe, 0x05, 0xb7, 0xe3,
	0x48, 0x44, 0x53, 0xc2, 0xdb, 0x50, 0x08, 0x5c, 0x31, 0x1d, 0x39, 0xdc, 0x87, 0xd2, 0x02, 0x1c,
	0xa5, 0xdd, 0xf1, 0x26, 0x11, 0x2e, 0xc3, 0x5c, 0xfd, 0x35, 0x44, 0xc8, 0xcf, 0x7c, 0xbe, 0x82,
	0x2c, 0xde, 0x81, 0xbd, 0x24, 0x16, 0x91, 0xed, 0xe2, 0x1e, 0xdc, 0x9a, 0x39, 0x63, 0x2a, 0xd6,
	0xf1, 0x10, 0xde, 0x5e, 0xe2, 0x88, 0x52, 0xf7, 0xca, 0x3f, 0x49, 0x90, 0x4f, 0x1e, 0x8f, 0xa8,
	0x42, 0x76, 0x62, 0x0c, 0xc9, 0xc4, 0x29, 0x4a, 0xe2, 0xe4, 0xb8, 0xbf, 0xe2, 0xa3, 0xd3, 0xe3,
	0x36, 0x65, 0xa7, 0xcf, 0xc9, 0xa5, 0x78, 0x2b, 0xb4, 0x20, 0x19, 0xab, 0xb0, 0xe3, 0x70, 0xc3,
	0xe6, 0x3a, 0xa7, 0x26, 0xd1, 0x5d, 0x46, 0x2f, 0x74, 0x66, 0x30, 0x4b, 0x9c, 0x05, 0x59, 0xad,
	0x20, 0x7c, 0x7d, 0x6a, 0x92, 0x01, 0xa3, 0x17, 0x6d, 0x83, 0x59, 0x78, 0x0f, 0xf2, 0x73, 0xa1,
	0x69, 0x11, 0xba, 0xc5, 0xe3, 0x51, 0x3b, 0xb0, 0x26, 0xde, 0x6a, 0x71, 0x3c, 0xa4, 0x35, 0xff,
	0xa1, 0xfc, 0xb3, 0x04, 0xdb, 0x73, 0x07, 0xf1, 0x7f, 0xa9, 0x0f, 0x29, 0xec, 0xe3, 0xcf, 0x0c,
	0xe0, 0xe2, 0x71, 0xff, 0xef, 0x6f, 0x65, 0x64, 0xb9, 0x8c, 0x8b, 0x56, 0x32, 0x9a, 0xff, 0x80,
	0x32, 0xa4, 0x1d, 0xd7, 0x14, 0x07, 0xae, 0xa4, 0x79, 0x26, 0xf6, 0x60, 0x7d, 0xe8, 0x8e, 0x5e,
	0x13, 0xee, 0x14, 0xb3, 0xa2, 0x8d, 0x4f, 0xaf, 0xff, 0xe5, 0xab, 0xd4, 0x04, 0x83, 0x16, 0x32,
	0xe1, 0xfb, 0xb0, 0x4d, 0x2e, 0xa6, 0x13, 0x3a, 0xa2, 0x5c, 0x1f, 0x5a, 0x2e, 0x1b, 0x3b, 0xc5,
	0xf5, 0xc3, 0xf4, 0x91, 0xa4, 0xe5, 0x43, 0xb8, 0x26, 0xd0, 0xd2, 0x8f, 0x29, 0xc8, 0xfa, 0xc9,
	0x91, 0x60, 0x29, 0x2e, 0xf8, 0x2b, 0xd8, 0x20, 0x17, 0xc4, 0x9c, 0x4e, 0x0c, 0x5b, 0x4c, 0x24,
	0x77, 0x5c, 0xfb, 0xc7, 0xfa, 0x2a, 0x6a, 0xc0, 0xa4, 0xcd, 0x38, 0x4b, 0x3f, 0x48, 0xb0, 0x11,
	0xc2, 0xd1, 0xf2, 0x4b, 0xb1, 0xe5, 0x5f, 0x32, 0xef, 0xd4, 0x92, 0x79, 0x77, 0x20, 0x67, 0x70,
	0x6e, 0x8c, 0xce, 0xbc, 0x0f, 0x43, 0xf8, 0x9f, 0x72, 0xcd, 0x2d, 0x11, 0x67, 0x28, 0x7f, 0x9f,
	0x06, 0x79, 0xfe, 0xf3, 0xff, 0x3f, 0xd9, 0x73, 0x16, 0x14, 0xa6, 0xc4, 0x1e, 0x11, 0xc6, 0xe9,
	0x84, 0xe8, 0x62, 0xca, 0xe1, 0xee, 0xab, 0x5d, 0xf7, 0x8f, 0xc8, 0xff, 0xb3, 0x50, 0x78, 0x77,
	0x46, 0xa8, 0xc9, 0x11, 0xb9, 0x70, 0x3a, 0xa5, 0x06, 0x14, 0x16, 0xc2, 0x70, 0x1f, 0x20, 0x0a,
	0x0c, 0x96, 0x3c, 0x86, 0x44, 0xbb, 0x21, 0x15, 0xdb, 0x0d, 0x35, 0x0e, 0xef, 0x50, 0x6b, 0x85,
	0xc8, 0xda, 0x56, 0x70, 0x79, 0xe8, 0x7a, 0x8e, 0xae, 0xf4, 0xf2, 0x8b, 0x53, 0xca, 0xcf, 0xdc,
	0xa1, 0xb7, 0x30, 0x55, 0x2f, 0xf5, 0x7e, 0x74, 0x09, 0x4b, 0x30, 0xdd, 0xf7, 0xaf, 0x64, 0xa7,
	0x84, 0x55, 0x4f, 0xe3, 0x77, 0xc2, 0x61, 0x56, 0x38, 0x3e, 0xf9, 0x2b, 0x00, 0x00, 0xff, 0xff,
	0xbd, 0xb8, 0xbe, 0xef, 0x3c, 0x0e, 0x00, 0x00,
}
