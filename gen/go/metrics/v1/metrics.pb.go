// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opentelemetry/proto/metrics/v1/metrics.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v11 "github.com/open-telemetry/opentelemetry-proto/gen/go/common/v1"
	v1 "github.com/open-telemetry/opentelemetry-proto/gen/go/resource/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ValueType is the type of values a metric has.  ValueType determines
// which field of the DataPoint will be used for Metrics with this
// descriptor.
type MetricDescriptor_ValueType int32

const (
	// INVALID_TYPE is the default ValueType, it MUST not be used.
	MetricDescriptor_INVALID_VALUE_TYPE MetricDescriptor_ValueType = 0
	// Metric.Points MUST use DataPoint.value_int64.
	MetricDescriptor_SCALAR_INT64 MetricDescriptor_ValueType = 2
	// Metric.Points MUST use DataPoint.value_double.
	MetricDescriptor_SCALAR_DOUBLE MetricDescriptor_ValueType = 3
	// Metric.Points MUST use DataPoint.histogram with int64 boundaries.
	MetricDescriptor_HISTOGRAM_INT64 MetricDescriptor_ValueType = 4
	// Metric.Points MUST use DataPoint.histogram with floating point boundaries.
	MetricDescriptor_HISTOGRAM_DOUBLE MetricDescriptor_ValueType = 5
	// Metric.Points MUST use DataPoint.summary with int64 min/max/sum/last values.
	MetricDescriptor_SUMMARY_INT64 MetricDescriptor_ValueType = 6
	// Metric.Points MUST use DataPoint.summary with double min/max/sum/last values.
	MetricDescriptor_SUMMARY_DOUBLE MetricDescriptor_ValueType = 7
	// Metric.Points MUST use DataPoint.raw with int64 values.
	MetricDescriptor_RAW_INT64 MetricDescriptor_ValueType = 8
	// Metric.Points MUST use DataPoint.raw with double value.
	MetricDescriptor_RAW_DOUBLE MetricDescriptor_ValueType = 9
)

var MetricDescriptor_ValueType_name = map[int32]string{
	0: "INVALID_VALUE_TYPE",
	2: "SCALAR_INT64",
	3: "SCALAR_DOUBLE",
	4: "HISTOGRAM_INT64",
	5: "HISTOGRAM_DOUBLE",
	6: "SUMMARY_INT64",
	7: "SUMMARY_DOUBLE",
	8: "RAW_INT64",
	9: "RAW_DOUBLE",
}

var MetricDescriptor_ValueType_value = map[string]int32{
	"INVALID_VALUE_TYPE": 0,
	"SCALAR_INT64":       2,
	"SCALAR_DOUBLE":      3,
	"HISTOGRAM_INT64":    4,
	"HISTOGRAM_DOUBLE":   5,
	"SUMMARY_INT64":      6,
	"SUMMARY_DOUBLE":     7,
	"RAW_INT64":          8,
	"RAW_DOUBLE":         9,
}

func (x MetricDescriptor_ValueType) String() string {
	return proto.EnumName(MetricDescriptor_ValueType_name, int32(x))
}

func (MetricDescriptor_ValueType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 0}
}

// KindMask contains a set of bit masks used to construct Kind enum values.
// There are 7 bits used presently.
type MetricDescriptor_KindMask int32

const (
	// INVALID_KIND_MASK is not used.
	MetricDescriptor_INVALID_KIND_MASK MetricDescriptor_KindMask = 0
	// INSTANTANEOUS is a metric whose values are measured at a particular
	// instant. The values are not aggregated over any time interval and are
	// unique per timestamp. As such, these metrics are not expected to have
	// an associated start time.
	MetricDescriptor_INSTANTANEOUS MetricDescriptor_KindMask = 1
	// DELTA is a metric whose values are the aggregation of measurements
	// made over a time interval. Successive metrics contain aggregation of
	// values from continuous and non-overlapping intervals.
	//
	// The values for a DELTA metric are based only on the time interval
	// associated with one measurement cycle. There is no dependency on
	// previous measurements like is the case for CUMULATIVE metrics.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// DELTA metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0+1 to
	//      t_0+2 with a value of 2.
	MetricDescriptor_DELTA MetricDescriptor_KindMask = 4
	// CUMULATIVE is a metric whose values are the aggregation of
	// successively made measurements from a fixed start time until the last
	// reported measurement. This means that current values of a CUMULATIVE
	// metric depend on all previous measurements since the start time.
	// Because of this, the sender is required to retain this state in some
	// form. If this state is lost or invalidated, the CUMULATIVE metric
	// values MUST be reset and a new fixed start time following the last
	// reported measurement time sent MUST be used.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// CUMULATIVE metric:
	//
	//   1. The system starts receiving at time=t_0.
	//   2. A request is received, the system measures 1 request.
	//   3. A request is received, the system measures 1 request.
	//   4. A request is received, the system measures 1 request.
	//   5. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+1 with a value of 3.
	//   6. A request is received, the system measures 1 request.
	//   7. A request is received, the system measures 1 request.
	//   8. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_0 to
	//      t_0+2 with a value of 5.
	//   9. The system experiences a fault and loses state.
	//   10. The system recovers and resumes receiving at time=t_1.
	//   11. A request is received, the system measures 1 request.
	//   12. The 1 second collection cycle ends. A metric is exported for the
	//      number of requests received over the interval of time t_1 to
	//      t_0+1 with a value of 1.
	MetricDescriptor_CUMULATIVE MetricDescriptor_KindMask = 2
	// GROUPING structure means the value has been computed by combining
	// individual values in a meaningful aggregation.
	// [TODO MrAlias wrote a good comment, use it]
	MetricDescriptor_GROUPING MetricDescriptor_KindMask = 8
	// ADDING structure means the value has been computed
	// [TODO MrAlias wrote a good comment, use it]
	MetricDescriptor_ADDING MetricDescriptor_KindMask = 16
	// MONOTONIC may be set in conjunction with ADDING kinds.
	MetricDescriptor_MONOTONIC MetricDescriptor_KindMask = 32
	// SYNCHRONOUS may be set for any kind of metric, indicating it was generated
	// through synchronous events in which the application calls the API.  If
	// SYNCHRONOUS is not set, it implies the event originated in a callback
	// where the SDK called the application.
	MetricDescriptor_SYNCHRONOUS MetricDescriptor_KindMask = 64
)

var MetricDescriptor_KindMask_name = map[int32]string{
	0:  "INVALID_KIND_MASK",
	1:  "INSTANTANEOUS",
	4:  "DELTA",
	2:  "CUMULATIVE",
	8:  "GROUPING",
	16: "ADDING",
	32: "MONOTONIC",
	64: "SYNCHRONOUS",
}

var MetricDescriptor_KindMask_value = map[string]int32{
	"INVALID_KIND_MASK": 0,
	"INSTANTANEOUS":     1,
	"DELTA":             4,
	"CUMULATIVE":        2,
	"GROUPING":          8,
	"ADDING":            16,
	"MONOTONIC":         32,
	"SYNCHRONOUS":       64,
}

func (x MetricDescriptor_KindMask) String() string {
	return proto.EnumName(MetricDescriptor_KindMask_name, int32(x))
}

func (MetricDescriptor_KindMask) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 1}
}

// Kind explains how the DataPoint was produced (Structure), how
// the point was aggregated with resepect to time (Temporality), and
// whether it was computed synchronously, and when the Structure is
// ADDING, whether the captured Sum is also monotonic.
//
// Kind names are generated from valid combinations of KindMask
// by joining the effective KindMasks using underscores.  There
// are:
//
// - 3 possibilities for Temporality
// - 2 possibilities for Synchronous/Asynchronous
// - 3 possibilities for Structure/Monotonicity: Grouping, Adding
//   Monotonic, and Adding (not monotonic)
//
// This makes 18 valid values.
type MetricDescriptor_Kind int32

const (
	// INVALID_KIND is the default Kind, it MUST not be used.
	MetricDescriptor_INVALID_KIND                                MetricDescriptor_Kind = 0
	MetricDescriptor_ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS  MetricDescriptor_Kind = 113
	MetricDescriptor_ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS MetricDescriptor_Kind = 49
	MetricDescriptor_ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS     MetricDescriptor_Kind = 114
	MetricDescriptor_ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS    MetricDescriptor_Kind = 50
	MetricDescriptor_ADDING_MONOTONIC_DELTA_SYNCHRONOUS          MetricDescriptor_Kind = 116
	MetricDescriptor_ADDING_MONOTONIC_DELTA_ASYNCHRONOUS         MetricDescriptor_Kind = 52
	MetricDescriptor_ADDING_INSTANTANEOUS_SYNCHRONOUS            MetricDescriptor_Kind = 81
	MetricDescriptor_ADDING_INSTANTANEOUS_ASYNCHRONOUS           MetricDescriptor_Kind = 17
	MetricDescriptor_ADDING_CUMULATIVE_SYNCHRONOUS               MetricDescriptor_Kind = 82
	MetricDescriptor_ADDING_CUMULATIVE_ASYNCHRONOUS              MetricDescriptor_Kind = 18
	MetricDescriptor_ADDING_DELTA_SYNCHRONOUS                    MetricDescriptor_Kind = 84
	MetricDescriptor_ADDING_DELTA_ASYNCHRONOUS                   MetricDescriptor_Kind = 20
	MetricDescriptor_GROUPING_INSTANTANEOUS_SYNCHRONOUS          MetricDescriptor_Kind = 73
	MetricDescriptor_GROUPING_INSTANTANEOUS_ASYNCHRONOUS         MetricDescriptor_Kind = 9
	MetricDescriptor_GROUPING_CUMULATIVE_SYNCHRONOUS             MetricDescriptor_Kind = 74
	MetricDescriptor_GROUPING_CUMULATIVE_ASYNCHRONOUS            MetricDescriptor_Kind = 10
	MetricDescriptor_GROUPING_DELTA_SYNCHRONOUS                  MetricDescriptor_Kind = 76
	MetricDescriptor_GROUPING_DELTA_ASYNCHRONOUS                 MetricDescriptor_Kind = 12
)

var MetricDescriptor_Kind_name = map[int32]string{
	0:   "INVALID_KIND",
	113: "ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS",
	49:  "ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS",
	114: "ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS",
	50:  "ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS",
	116: "ADDING_MONOTONIC_DELTA_SYNCHRONOUS",
	52:  "ADDING_MONOTONIC_DELTA_ASYNCHRONOUS",
	81:  "ADDING_INSTANTANEOUS_SYNCHRONOUS",
	17:  "ADDING_INSTANTANEOUS_ASYNCHRONOUS",
	82:  "ADDING_CUMULATIVE_SYNCHRONOUS",
	18:  "ADDING_CUMULATIVE_ASYNCHRONOUS",
	84:  "ADDING_DELTA_SYNCHRONOUS",
	20:  "ADDING_DELTA_ASYNCHRONOUS",
	73:  "GROUPING_INSTANTANEOUS_SYNCHRONOUS",
	9:   "GROUPING_INSTANTANEOUS_ASYNCHRONOUS",
	74:  "GROUPING_CUMULATIVE_SYNCHRONOUS",
	10:  "GROUPING_CUMULATIVE_ASYNCHRONOUS",
	76:  "GROUPING_DELTA_SYNCHRONOUS",
	12:  "GROUPING_DELTA_ASYNCHRONOUS",
}

var MetricDescriptor_Kind_value = map[string]int32{
	"INVALID_KIND": 0,
	"ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS":  113,
	"ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS": 49,
	"ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS":     114,
	"ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS":    50,
	"ADDING_MONOTONIC_DELTA_SYNCHRONOUS":          116,
	"ADDING_MONOTONIC_DELTA_ASYNCHRONOUS":         52,
	"ADDING_INSTANTANEOUS_SYNCHRONOUS":            81,
	"ADDING_INSTANTANEOUS_ASYNCHRONOUS":           17,
	"ADDING_CUMULATIVE_SYNCHRONOUS":               82,
	"ADDING_CUMULATIVE_ASYNCHRONOUS":              18,
	"ADDING_DELTA_SYNCHRONOUS":                    84,
	"ADDING_DELTA_ASYNCHRONOUS":                   20,
	"GROUPING_INSTANTANEOUS_SYNCHRONOUS":          73,
	"GROUPING_INSTANTANEOUS_ASYNCHRONOUS":         9,
	"GROUPING_CUMULATIVE_SYNCHRONOUS":             74,
	"GROUPING_CUMULATIVE_ASYNCHRONOUS":            10,
	"GROUPING_DELTA_SYNCHRONOUS":                  76,
	"GROUPING_DELTA_ASYNCHRONOUS":                 12,
}

func (x MetricDescriptor_Kind) String() string {
	return proto.EnumName(MetricDescriptor_Kind_name, int32(x))
}

func (MetricDescriptor_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 2}
}

// A collection of InstrumentationLibraryMetrics from a Resource.
type ResourceMetrics struct {
	// The resource for the metrics in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of metrics that originate from a resource.
	InstrumentationLibraryMetrics []*InstrumentationLibraryMetrics `protobuf:"bytes,2,rep,name=instrumentation_library_metrics,json=instrumentationLibraryMetrics,proto3" json:"instrumentation_library_metrics,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                         `json:"-"`
	XXX_unrecognized              []byte                           `json:"-"`
	XXX_sizecache                 int32                            `json:"-"`
}

func (m *ResourceMetrics) Reset()         { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()    {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{0}
}

func (m *ResourceMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceMetrics.Unmarshal(m, b)
}
func (m *ResourceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceMetrics.Marshal(b, m, deterministic)
}
func (m *ResourceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMetrics.Merge(m, src)
}
func (m *ResourceMetrics) XXX_Size() int {
	return xxx_messageInfo_ResourceMetrics.Size(m)
}
func (m *ResourceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMetrics proto.InternalMessageInfo

func (m *ResourceMetrics) GetResource() *v1.Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceMetrics) GetInstrumentationLibraryMetrics() []*InstrumentationLibraryMetrics {
	if m != nil {
		return m.InstrumentationLibraryMetrics
	}
	return nil
}

// A collection of Metrics produced by an InstrumentationLibrary.
type InstrumentationLibraryMetrics struct {
	// The instrumentation library information for the metrics in this message.
	// If this field is not set then no library info is known.
	InstrumentationLibrary *v11.InstrumentationLibrary `protobuf:"bytes,1,opt,name=instrumentation_library,json=instrumentationLibrary,proto3" json:"instrumentation_library,omitempty"`
	// A list of metrics that originate from an instrumentation library.
	Metrics              []*Metric `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstrumentationLibraryMetrics) Reset()         { *m = InstrumentationLibraryMetrics{} }
func (m *InstrumentationLibraryMetrics) String() string { return proto.CompactTextString(m) }
func (*InstrumentationLibraryMetrics) ProtoMessage()    {}
func (*InstrumentationLibraryMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{1}
}

func (m *InstrumentationLibraryMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Unmarshal(m, b)
}
func (m *InstrumentationLibraryMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Marshal(b, m, deterministic)
}
func (m *InstrumentationLibraryMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstrumentationLibraryMetrics.Merge(m, src)
}
func (m *InstrumentationLibraryMetrics) XXX_Size() int {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Size(m)
}
func (m *InstrumentationLibraryMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_InstrumentationLibraryMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_InstrumentationLibraryMetrics proto.InternalMessageInfo

func (m *InstrumentationLibraryMetrics) GetInstrumentationLibrary() *v11.InstrumentationLibrary {
	if m != nil {
		return m.InstrumentationLibrary
	}
	return nil
}

func (m *InstrumentationLibraryMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Defines a Metric which has one or more timeseries.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a name, description, unit, kind, and value type.
// - Points is a list of DataPoints (shown vertically).
// - DataPoint contains timestamps, labels, and one of the value type fields.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         | name                   |
//  |          |         | description            |
//  |          |         | unit                   |
//  |    points|--+      | kind                   |
//  +----------+  |      | value type             |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
// DataPoint is a general type that includes three common fields:
// - Labels are the optional key, value pairs associated with the data point.
// - StartTimeUnixNano MUST be set to the start of the interval when the
//   descriptor kind includes MASK_CUMULATIVE or MASK_DELTA.
// - TimeUnixNano MUST be set to:
//   - the end of the interval (MASK_CUMULATIVE or MASK_DELTA)
//   - the instantaneous time of the event (MASK_INSTANTANEOUS).
//
// DataPoint values are strongly typed: each DataPoint uses a specific field
// depending on the value type of the metric.  The scalar value types
// (SCALAR_INT64, SCALAR_DOUBLE) use fields of the DataPoint directly, while
// there are currently 3 DataPoint sub-messages (Histogram, Summary, RawValue).
type Metric struct {
	// metric_descriptor describes the Metric.
	MetricDescriptor *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor,proto3" json:"metric_descriptor,omitempty"`
	// Points is a list of one or more DataPoints for a single metric.
	Points               []*DataPoint `protobuf:"bytes,2,rep,name=points,proto3" json:"points,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetPoints() []*DataPoint {
	if m != nil {
		return m.Points
	}
	return nil
}

// Defines a metric type and its schema.
type MetricDescriptor struct {
	// name of the metric, including its DNS name prefix. It must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description of the metric, which can be used in documentation.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// value_type is the type of values this metric has.
	ValueType MetricDescriptor_ValueType `protobuf:"varint,4,opt,name=value_type,json=valueType,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_ValueType" json:"value_type,omitempty"`
	// Kind describes properties of the Metric that are necessary to
	// interpret the data and/or describe how it was produced.
	Kind                 MetricDescriptor_Kind `protobuf:"varint,5,opt,name=kind,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Kind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetricDescriptor) Reset()         { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()    {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3}
}

func (m *MetricDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricDescriptor.Unmarshal(m, b)
}
func (m *MetricDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricDescriptor.Marshal(b, m, deterministic)
}
func (m *MetricDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDescriptor.Merge(m, src)
}
func (m *MetricDescriptor) XXX_Size() int {
	return xxx_messageInfo_MetricDescriptor.Size(m)
}
func (m *MetricDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDescriptor proto.InternalMessageInfo

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetValueType() MetricDescriptor_ValueType {
	if m != nil {
		return m.ValueType
	}
	return MetricDescriptor_INVALID_VALUE_TYPE
}

func (m *MetricDescriptor) GetKind() MetricDescriptor_Kind {
	if m != nil {
		return m.Kind
	}
	return MetricDescriptor_INVALID_KIND
}

// DataPoint is a point of raw or aggregate metric data, generally containing
// the labels, one or two timestamps, and a single value field.  The value field
// that is used is determined by the descriptor ValueType.
type DataPoint struct {
	// The set of labels that uniquely identify this timeseries.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the start of the interval for which a CUMULATIVE or
	// DELTA kind of metric was computed.
	// reset.
	//
	// This must not be set for INSTANTANEOUS metric kinds.
	//
	// The cumulative or delta value is over the time interval (start_time_unix_nano, time_unix_nano].
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// TODO: Can we omit this when all metrics in a report share the same start time?
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the end of the interval for CUMULATIVE and DELTA kinds,
	// or it is the event timestamp for INSTANTANEOUS kinds.
	//
	// TODO: Can we omit this when a non-instantaneous metric has the same end time
	// as others in the report?
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// SCALAR_INT64 uses this.
	ValueInt64 int64 `protobuf:"varint,4,opt,name=value_int64,json=valueInt64,proto3" json:"value_int64,omitempty"`
	// SCALAR_DOUBLE uses this.
	ValueDouble float64 `protobuf:"fixed64,5,opt,name=value_double,json=valueDouble,proto3" json:"value_double,omitempty"`
	// HISTOGRAM_INT64 and HISTOGRAM_DOUBLE use this.
	Histogram *Histogram `protobuf:"bytes,6,opt,name=histogram,proto3" json:"histogram,omitempty"`
	// SUMMARY_INT64 and SUMMARU_DOUBLE use this.
	Summary *Summary `protobuf:"bytes,7,opt,name=summary,proto3" json:"summary,omitempty"`
	// Exemplars are the value for RAW_INT64 and RAW_DOUBLE ValueTypes.
	//
	// Exemplars may also be set alongside any other ValueType than RAW_INT64
	// or RAW_DOUBLE, in which case the exemplars carry additional information,
	// including the full label set, exact timestamp, and optional trace context
	// and sampling information.
	Exemplars            []*RawValue `protobuf:"bytes,8,rep,name=exemplars,proto3" json:"exemplars,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DataPoint) Reset()         { *m = DataPoint{} }
func (m *DataPoint) String() string { return proto.CompactTextString(m) }
func (*DataPoint) ProtoMessage()    {}
func (*DataPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4}
}

func (m *DataPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DataPoint.Unmarshal(m, b)
}
func (m *DataPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DataPoint.Marshal(b, m, deterministic)
}
func (m *DataPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataPoint.Merge(m, src)
}
func (m *DataPoint) XXX_Size() int {
	return xxx_messageInfo_DataPoint.Size(m)
}
func (m *DataPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_DataPoint.DiscardUnknown(m)
}

var xxx_messageInfo_DataPoint proto.InternalMessageInfo

func (m *DataPoint) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *DataPoint) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *DataPoint) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *DataPoint) GetValueInt64() int64 {
	if m != nil {
		return m.ValueInt64
	}
	return 0
}

func (m *DataPoint) GetValueDouble() float64 {
	if m != nil {
		return m.ValueDouble
	}
	return 0
}

func (m *DataPoint) GetHistogram() *Histogram {
	if m != nil {
		return m.Histogram
	}
	return nil
}

func (m *DataPoint) GetSummary() *Summary {
	if m != nil {
		return m.Summary
	}
	return nil
}

func (m *DataPoint) GetExemplars() []*RawValue {
	if m != nil {
		return m.Exemplars
	}
	return nil
}

// Histogram is a single data point in a timeseries that describes the time-varying
// values of a Histogram. A Histogram contains summary statistics for a population of values,
// it may optionally contain the distribution of those values across a set of buckets.
type Histogram struct {
	// count is the number of values in the population. Must be non-negative. This value
	// must be equal to the sum of the "count" fields in buckets if a histogram is provided.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// sum of the values in the population. If count is zero then this field
	// must be zero. This value must be equal to the sum of the "sum" fields in buckets if
	// a histogram is provided.
	SumInt64  int64   `protobuf:"varint,2,opt,name=sum_int64,json=sumInt64,proto3" json:"sum_int64,omitempty"`
	SumDouble float64 `protobuf:"fixed64,3,opt,name=sum_double,json=sumDouble,proto3" json:"sum_double,omitempty"`
	// buckets is an optional field contains the values of histogram for each bucket.
	//
	// The sum of the values in the buckets "count" field must equal the value in the count field.
	//
	// The number of elements in buckets array must be by one greater than the
	// number of elements in bucket_bounds array.
	//
	// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
	// must also be present and number of elements in this field must be equal to the
	// number of buckets defined by bucket_options.
	Buckets []*Histogram_Bucket `protobuf:"bytes,6,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// explicit_bounds specifies buckets with explicitly defined bounds for values.
	// The bucket boundaries are described by "bounds" field.
	//
	// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
	// at index i are:
	//
	// [0, bounds[i]) for i == 0
	// [bounds[i-1], bounds[i]) for 0 < i < N-1
	// [bounds[i], +infinity) for i == N-1
	// The values in bounds array must be strictly increasing and > 0.
	//
	// Note: only [a, b) intervals are currently supported for each bucket. If we decides
	// to also support (a, b] intervals we should add support for these by defining a boolean
	// value which decides what type of intervals to use.
	ExplicitBoundsInt64  []int64   `protobuf:"varint,7,rep,packed,name=explicit_bounds_int64,json=explicitBoundsInt64,proto3" json:"explicit_bounds_int64,omitempty"`
	ExplicitBoundsDouble []float64 `protobuf:"fixed64,8,rep,packed,name=explicit_bounds_double,json=explicitBoundsDouble,proto3" json:"explicit_bounds_double,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{5}
}

func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Histogram.Unmarshal(m, b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return xxx_messageInfo_Histogram.Size(m)
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

func (m *Histogram) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Histogram) GetSumInt64() int64 {
	if m != nil {
		return m.SumInt64
	}
	return 0
}

func (m *Histogram) GetSumDouble() float64 {
	if m != nil {
		return m.SumDouble
	}
	return 0
}

func (m *Histogram) GetBuckets() []*Histogram_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Histogram) GetExplicitBoundsInt64() []int64 {
	if m != nil {
		return m.ExplicitBoundsInt64
	}
	return nil
}

func (m *Histogram) GetExplicitBoundsDouble() []float64 {
	if m != nil {
		return m.ExplicitBoundsDouble
	}
	return nil
}

// Bucket contains values for a bucket.
type Histogram_Bucket struct {
	// The number of values in each bucket of the histogram, as described by
	// bucket_options.
	Count                uint64   `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Histogram_Bucket) Reset()         { *m = Histogram_Bucket{} }
func (m *Histogram_Bucket) String() string { return proto.CompactTextString(m) }
func (*Histogram_Bucket) ProtoMessage()    {}
func (*Histogram_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{5, 0}
}

func (m *Histogram_Bucket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Histogram_Bucket.Unmarshal(m, b)
}
func (m *Histogram_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Histogram_Bucket.Marshal(b, m, deterministic)
}
func (m *Histogram_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram_Bucket.Merge(m, src)
}
func (m *Histogram_Bucket) XXX_Size() int {
	return xxx_messageInfo_Histogram_Bucket.Size(m)
}
func (m *Histogram_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram_Bucket proto.InternalMessageInfo

func (m *Histogram_Bucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Summary is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
type Summary struct {
	// Remove the labels, start_time, and time TODO.
	//
	// fields: Add min, max, last fields
	// as described in https://github.com/open-telemetry/oteps/pull/117
	//
	// (Same comment)
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// (Same comment)
	SumInt64  int64   `protobuf:"varint,2,opt,name=sum_int64,json=sumInt64,proto3" json:"sum_int64,omitempty"`
	SumDouble float64 `protobuf:"fixed64,3,opt,name=sum_double,json=sumDouble,proto3" json:"sum_double,omitempty"`
	// MIN, MAX, LAST value
	MinInt64   int64   `protobuf:"varint,4,opt,name=min_int64,json=minInt64,proto3" json:"min_int64,omitempty"`
	MinDouble  float64 `protobuf:"fixed64,5,opt,name=min_double,json=minDouble,proto3" json:"min_double,omitempty"`
	MaxInt64   int64   `protobuf:"varint,6,opt,name=max_int64,json=maxInt64,proto3" json:"max_int64,omitempty"`
	MaxDouble  float64 `protobuf:"fixed64,7,opt,name=max_double,json=maxDouble,proto3" json:"max_double,omitempty"`
	LastInt64  int64   `protobuf:"varint,8,opt,name=last_int64,json=lastInt64,proto3" json:"last_int64,omitempty"`
	LastDouble float64 `protobuf:"fixed64,9,opt,name=last_double,json=lastDouble,proto3" json:"last_double,omitempty"`
	// (Same comment)
	QuantileValues       []*Summary_ValueAtQuantile `protobuf:"bytes,10,rep,name=quantile_values,json=quantileValues,proto3" json:"quantile_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Summary) Reset()         { *m = Summary{} }
func (m *Summary) String() string { return proto.CompactTextString(m) }
func (*Summary) ProtoMessage()    {}
func (*Summary) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{6}
}

func (m *Summary) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Summary.Unmarshal(m, b)
}
func (m *Summary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Summary.Marshal(b, m, deterministic)
}
func (m *Summary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Summary.Merge(m, src)
}
func (m *Summary) XXX_Size() int {
	return xxx_messageInfo_Summary.Size(m)
}
func (m *Summary) XXX_DiscardUnknown() {
	xxx_messageInfo_Summary.DiscardUnknown(m)
}

var xxx_messageInfo_Summary proto.InternalMessageInfo

func (m *Summary) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Summary) GetSumInt64() int64 {
	if m != nil {
		return m.SumInt64
	}
	return 0
}

func (m *Summary) GetSumDouble() float64 {
	if m != nil {
		return m.SumDouble
	}
	return 0
}

func (m *Summary) GetMinInt64() int64 {
	if m != nil {
		return m.MinInt64
	}
	return 0
}

func (m *Summary) GetMinDouble() float64 {
	if m != nil {
		return m.MinDouble
	}
	return 0
}

func (m *Summary) GetMaxInt64() int64 {
	if m != nil {
		return m.MaxInt64
	}
	return 0
}

func (m *Summary) GetMaxDouble() float64 {
	if m != nil {
		return m.MaxDouble
	}
	return 0
}

func (m *Summary) GetLastInt64() int64 {
	if m != nil {
		return m.LastInt64
	}
	return 0
}

func (m *Summary) GetLastDouble() float64 {
	if m != nil {
		return m.LastDouble
	}
	return 0
}

func (m *Summary) GetQuantileValues() []*Summary_ValueAtQuantile {
	if m != nil {
		return m.QuantileValues
	}
	return nil
}

// (Similar comments)
type Summary_ValueAtQuantile struct {
	Quantile             float64  `protobuf:"fixed64,1,opt,name=quantile,proto3" json:"quantile,omitempty"`
	ValueInt64           int64    `protobuf:"varint,2,opt,name=value_int64,json=valueInt64,proto3" json:"value_int64,omitempty"`
	ValueDouble          float64  `protobuf:"fixed64,3,opt,name=value_double,json=valueDouble,proto3" json:"value_double,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Summary_ValueAtQuantile) Reset()         { *m = Summary_ValueAtQuantile{} }
func (m *Summary_ValueAtQuantile) String() string { return proto.CompactTextString(m) }
func (*Summary_ValueAtQuantile) ProtoMessage()    {}
func (*Summary_ValueAtQuantile) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{6, 0}
}

func (m *Summary_ValueAtQuantile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Summary_ValueAtQuantile.Unmarshal(m, b)
}
func (m *Summary_ValueAtQuantile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Summary_ValueAtQuantile.Marshal(b, m, deterministic)
}
func (m *Summary_ValueAtQuantile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Summary_ValueAtQuantile.Merge(m, src)
}
func (m *Summary_ValueAtQuantile) XXX_Size() int {
	return xxx_messageInfo_Summary_ValueAtQuantile.Size(m)
}
func (m *Summary_ValueAtQuantile) XXX_DiscardUnknown() {
	xxx_messageInfo_Summary_ValueAtQuantile.DiscardUnknown(m)
}

var xxx_messageInfo_Summary_ValueAtQuantile proto.InternalMessageInfo

func (m *Summary_ValueAtQuantile) GetQuantile() float64 {
	if m != nil {
		return m.Quantile
	}
	return 0
}

func (m *Summary_ValueAtQuantile) GetValueInt64() int64 {
	if m != nil {
		return m.ValueInt64
	}
	return 0
}

func (m *Summary_ValueAtQuantile) GetValueDouble() float64 {
	if m != nil {
		return m.ValueDouble
	}
	return 0
}

type RawValue struct {
	// Numerical value of the measurement that was recorded. Only one of these
	// two fields is used for the data, based on MetricDescriptor.measurement_type
	ValueDouble float64 `protobuf:"fixed64,1,opt,name=value_double,json=valueDouble,proto3" json:"value_double,omitempty"`
	ValueInt64  int64   `protobuf:"varint,2,opt,name=value_int64,json=valueInt64,proto3" json:"value_int64,omitempty"`
	// Exact time that the measurement was recorded
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// Labels that were passed with the measurement, but not included in the DataPoint's labels
	AdditionalLabels []*v11.StringKeyValue `protobuf:"bytes,4,rep,name=additional_labels,json=additionalLabels,proto3" json:"additional_labels,omitempty"`
	// (Optional) Span ID of the current trace
	SpanId []byte `protobuf:"bytes,5,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	// (Optional) Trace ID of the current trace
	TraceId []byte `protobuf:"bytes,6,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	// (Optional) When sample_count is non-zero, this exemplar has been chosen in a statistically
	// unbiased way such that the exemplar is representative of `sample_count` individual events
	SampleCount          float64  `protobuf:"fixed64,7,opt,name=sample_count,json=sampleCount,proto3" json:"sample_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawValue) Reset()         { *m = RawValue{} }
func (m *RawValue) String() string { return proto.CompactTextString(m) }
func (*RawValue) ProtoMessage()    {}
func (*RawValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{7}
}

func (m *RawValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RawValue.Unmarshal(m, b)
}
func (m *RawValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RawValue.Marshal(b, m, deterministic)
}
func (m *RawValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawValue.Merge(m, src)
}
func (m *RawValue) XXX_Size() int {
	return xxx_messageInfo_RawValue.Size(m)
}
func (m *RawValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RawValue.DiscardUnknown(m)
}

var xxx_messageInfo_RawValue proto.InternalMessageInfo

func (m *RawValue) GetValueDouble() float64 {
	if m != nil {
		return m.ValueDouble
	}
	return 0
}

func (m *RawValue) GetValueInt64() int64 {
	if m != nil {
		return m.ValueInt64
	}
	return 0
}

func (m *RawValue) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *RawValue) GetAdditionalLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.AdditionalLabels
	}
	return nil
}

func (m *RawValue) GetSpanId() []byte {
	if m != nil {
		return m.SpanId
	}
	return nil
}

func (m *RawValue) GetTraceId() []byte {
	if m != nil {
		return m.TraceId
	}
	return nil
}

func (m *RawValue) GetSampleCount() float64 {
	if m != nil {
		return m.SampleCount
	}
	return 0
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_ValueType", MetricDescriptor_ValueType_name, MetricDescriptor_ValueType_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_KindMask", MetricDescriptor_KindMask_name, MetricDescriptor_KindMask_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Kind", MetricDescriptor_Kind_name, MetricDescriptor_Kind_value)
	proto.RegisterType((*ResourceMetrics)(nil), "opentelemetry.proto.metrics.v1.ResourceMetrics")
	proto.RegisterType((*InstrumentationLibraryMetrics)(nil), "opentelemetry.proto.metrics.v1.InstrumentationLibraryMetrics")
	proto.RegisterType((*Metric)(nil), "opentelemetry.proto.metrics.v1.Metric")
	proto.RegisterType((*MetricDescriptor)(nil), "opentelemetry.proto.metrics.v1.MetricDescriptor")
	proto.RegisterType((*DataPoint)(nil), "opentelemetry.proto.metrics.v1.DataPoint")
	proto.RegisterType((*Histogram)(nil), "opentelemetry.proto.metrics.v1.Histogram")
	proto.RegisterType((*Histogram_Bucket)(nil), "opentelemetry.proto.metrics.v1.Histogram.Bucket")
	proto.RegisterType((*Summary)(nil), "opentelemetry.proto.metrics.v1.Summary")
	proto.RegisterType((*Summary_ValueAtQuantile)(nil), "opentelemetry.proto.metrics.v1.Summary.ValueAtQuantile")
	proto.RegisterType((*RawValue)(nil), "opentelemetry.proto.metrics.v1.RawValue")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/metrics/v1/metrics.proto", fileDescriptor_3c3112f9fa006917)
}

var fileDescriptor_3c3112f9fa006917 = []byte{
	// 1371 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x0e, 0x25, 0x59, 0x12, 0x8f, 0x1d, 0x9b, 0x9e, 0x38, 0x89, 0xe2, 0xfc, 0xbe, 0x29, 0xf9,
	0x13, 0xe7, 0x26, 0xc5, 0xae, 0x93, 0x02, 0x05, 0x8a, 0x86, 0xb6, 0x54, 0x87, 0xb1, 0x2e, 0xce,
	0x48, 0x72, 0xe1, 0x00, 0x05, 0x4b, 0x49, 0x84, 0x43, 0x44, 0x24, 0x15, 0x72, 0xe8, 0xca, 0x0f,
	0xd0, 0x45, 0xdf, 0xa2, 0xbb, 0x02, 0xdd, 0x76, 0xd5, 0x65, 0x1f, 0xa1, 0xe8, 0x0b, 0x74, 0xd9,
	0xc7, 0x28, 0xe6, 0x42, 0x49, 0xd4, 0xc5, 0x72, 0x0a, 0x74, 0x37, 0x3c, 0xe7, 0xfb, 0xbe, 0x39,
	0xe7, 0xe3, 0xf0, 0x90, 0x84, 0xa7, 0x6e, 0xd7, 0x74, 0x88, 0xd9, 0x31, 0x6d, 0x93, 0x78, 0x17,
	0xf9, 0xae, 0xe7, 0x12, 0x37, 0x4f, 0xd7, 0x56, 0xcb, 0xcf, 0x9f, 0xef, 0x84, 0xcb, 0x1c, 0x4b,
	0xa0, 0xf5, 0x08, 0x9a, 0x07, 0x73, 0x21, 0xe4, 0x7c, 0x67, 0xf5, 0xf1, 0x24, 0xb5, 0x96, 0x6b,
	0xdb, 0xae, 0x43, 0xc5, 0xf8, 0x8a, 0xd3, 0x56, 0x73, 0x93, 0xb0, 0x9e, 0xe9, 0xbb, 0x81, 0xd7,
	0x32, 0x29, 0x3a, 0x5c, 0x73, 0x7c, 0xf6, 0x2f, 0x09, 0x96, 0xb0, 0x08, 0x95, 0xf9, 0x96, 0xa8,
	0x08, 0xe9, 0x10, 0x95, 0x91, 0x36, 0xa5, 0xed, 0xf9, 0xdd, 0x47, 0xb9, 0x49, 0x25, 0xf6, 0xa5,
	0xce, 0x77, 0x72, 0xa1, 0x06, 0xee, 0x53, 0xd1, 0x0f, 0x12, 0x6c, 0x58, 0x8e, 0x4f, 0xbc, 0xc0,
	0x36, 0x1d, 0x62, 0x10, 0xcb, 0x75, 0xf4, 0x8e, 0xd5, 0xf4, 0x0c, 0xef, 0x42, 0x17, 0xdd, 0x65,
	0x62, 0x9b, 0xf1, 0xed, 0xf9, 0xdd, 0x2f, 0x73, 0x97, 0x3b, 0x90, 0xd3, 0xa2, 0x32, 0x25, 0xae,
	0x22, 0xea, 0xc5, 0x6b, 0xd6, 0x65, 0xe9, 0xec, 0x1f, 0x12, 0xac, 0x5d, 0x2a, 0x80, 0x1c, 0xb8,
	0x3d, 0xa5, 0x50, 0xd1, 0xff, 0x8b, 0x89, 0x05, 0x0a, 0xe3, 0xa7, 0xd6, 0x87, 0x6f, 0x4d, 0x2e,
	0x0c, 0xbd, 0x82, 0x54, 0xd4, 0x80, 0x07, 0xb3, 0x0c, 0xe0, 0x95, 0xe2, 0x90, 0x96, 0xfd, 0x45,
	0x82, 0x24, 0x8f, 0xa1, 0x6f, 0x61, 0x99, 0x47, 0xf5, 0xb6, 0xe9, 0xb7, 0x3c, 0xab, 0x4b, 0x5c,
	0x4f, 0x94, 0xfd, 0xfc, 0x6a, 0xb2, 0x85, 0x3e, 0x0f, 0x2b, 0xf6, 0x48, 0x04, 0xa9, 0x90, 0xec,
	0xba, 0x96, 0x43, 0xc2, 0x52, 0x1f, 0xcd, 0xd2, 0x2c, 0x18, 0xc4, 0x38, 0xa6, 0x0c, 0x2c, 0x88,
	0xd9, 0x9f, 0x00, 0x94, 0xd1, 0x9d, 0x10, 0x82, 0x84, 0x63, 0xd8, 0xfc, 0x80, 0xc9, 0x98, 0xad,
	0xd1, 0x26, 0xcc, 0x87, 0x3d, 0x58, 0xae, 0x93, 0x89, 0xb1, 0xd4, 0x70, 0x88, 0xb2, 0x02, 0xc7,
	0x22, 0x99, 0x38, 0x67, 0xd1, 0x35, 0x3a, 0x05, 0x38, 0x37, 0x3a, 0x81, 0xa9, 0x93, 0x8b, 0xae,
	0x99, 0x49, 0x6c, 0x4a, 0xdb, 0x8b, 0xbb, 0x5f, 0x7c, 0x6a, 0xe7, 0xb9, 0x13, 0x2a, 0x51, 0xbf,
	0xe8, 0x9a, 0x58, 0x3e, 0x0f, 0x97, 0x48, 0x83, 0xc4, 0x07, 0xcb, 0x69, 0x67, 0xe6, 0x98, 0xe8,
	0x8b, 0x4f, 0x16, 0x3d, 0xb2, 0x9c, 0x36, 0x66, 0x12, 0xd9, 0xdf, 0x24, 0x90, 0xfb, 0x7b, 0xa0,
	0x5b, 0x80, 0xb4, 0xca, 0x89, 0x5a, 0xd2, 0x0a, 0xfa, 0x89, 0x5a, 0x6a, 0x14, 0xf5, 0xfa, 0xe9,
	0x71, 0x51, 0xb9, 0x86, 0x14, 0x58, 0xa8, 0x1d, 0xa8, 0x25, 0x15, 0xeb, 0x5a, 0xa5, 0xfe, 0x72,
	0x4f, 0x89, 0xa1, 0x65, 0xb8, 0x2e, 0x22, 0x85, 0x6a, 0x63, 0xbf, 0x54, 0x54, 0xe2, 0xe8, 0x06,
	0x2c, 0xbd, 0xd6, 0x6a, 0xf5, 0xea, 0x21, 0x56, 0xcb, 0x02, 0x97, 0x40, 0x2b, 0xa0, 0x0c, 0x82,
	0x02, 0x3a, 0xc7, 0xd8, 0x8d, 0x72, 0x59, 0xc5, 0xa7, 0x02, 0x98, 0x44, 0x08, 0x16, 0xc3, 0x90,
	0x80, 0xa5, 0xd0, 0x75, 0x90, 0xb1, 0xfa, 0x8d, 0x80, 0xa4, 0xd1, 0x22, 0x00, 0xbd, 0x14, 0x69,
	0x39, 0xfb, 0xa3, 0x04, 0x69, 0xda, 0x4a, 0xd9, 0xf0, 0x3f, 0xa0, 0x9b, 0xb0, 0x1c, 0x96, 0x7e,
	0xa4, 0x55, 0x0a, 0x7a, 0x59, 0xad, 0x1d, 0x29, 0xd7, 0xe8, 0x4e, 0x5a, 0xa5, 0x56, 0x57, 0x2b,
	0x75, 0xb5, 0x52, 0xac, 0x36, 0x6a, 0x8a, 0x84, 0x64, 0x98, 0x2b, 0x14, 0x4b, 0x75, 0x55, 0x49,
	0x50, 0xc5, 0x83, 0x46, 0xb9, 0x51, 0x52, 0xeb, 0xda, 0x49, 0x51, 0x89, 0xa1, 0x05, 0x48, 0x1f,
	0xe2, 0x6a, 0xe3, 0x58, 0xab, 0x1c, 0x2a, 0x69, 0x04, 0x90, 0x54, 0x0b, 0x05, 0xba, 0x56, 0x68,
	0x29, 0xe5, 0x6a, 0xa5, 0x5a, 0xaf, 0x56, 0xb4, 0x03, 0x65, 0x13, 0x2d, 0xc1, 0x7c, 0xed, 0xb4,
	0x72, 0xf0, 0x1a, 0x57, 0x2b, 0x54, 0xf4, 0x55, 0xf6, 0xcf, 0x39, 0x48, 0xd0, 0x5a, 0xa8, 0x55,
	0xc3, 0x75, 0x28, 0xd7, 0x50, 0x0e, 0x1e, 0x73, 0x19, 0xbd, 0xaf, 0xa0, 0x47, 0x6a, 0xd2, 0x87,
	0xa5, 0x3e, 0xa2, 0x3c, 0x3c, 0x99, 0x81, 0x57, 0x87, 0x09, 0x3b, 0xe8, 0x09, 0x3c, 0x1c, 0x23,
	0x0c, 0xda, 0x8a, 0xa8, 0x7b, 0xe8, 0x29, 0x6c, 0x5f, 0x06, 0x8e, 0x48, 0xef, 0xa2, 0x07, 0x90,
	0x1d, 0x43, 0x33, 0xf3, 0x22, 0xaa, 0x04, 0x3d, 0x84, 0x7b, 0x53, 0x70, 0x11, 0xc1, 0x3d, 0x74,
	0x1f, 0x36, 0x05, 0x70, 0xba, 0x05, 0x6f, 0xd1, 0xff, 0x61, 0x6b, 0x22, 0x2a, 0x22, 0xb6, 0x8c,
	0xb6, 0x60, 0x4d, 0xc0, 0xa6, 0xb4, 0x8b, 0x51, 0x16, 0xd6, 0xc7, 0x21, 0x11, 0x19, 0x84, 0xfe,
	0x07, 0x19, 0x81, 0x19, 0x6f, 0xad, 0x8e, 0xd6, 0xe0, 0x4e, 0x24, 0x1b, 0x21, 0xaf, 0x50, 0x87,
	0xc2, 0x23, 0x73, 0x49, 0x4b, 0x1a, 0x75, 0x68, 0x0a, 0x2e, 0x22, 0x28, 0xa3, 0x7b, 0xb0, 0xd1,
	0x07, 0x4e, 0x69, 0xeb, 0x0d, 0xb5, 0x71, 0x12, 0x28, 0x22, 0x05, 0x68, 0x1d, 0x56, 0xfb, 0xa8,
	0xf1, 0xd6, 0x4a, 0x68, 0x03, 0xee, 0x8e, 0xe4, 0x23, 0x02, 0x0b, 0xd9, 0xdf, 0xe3, 0x20, 0xf7,
	0x07, 0x27, 0x2a, 0x42, 0xb2, 0x63, 0x34, 0xcd, 0x8e, 0x9f, 0x91, 0xd8, 0xcc, 0x7d, 0x36, 0xe3,
	0xf5, 0x53, 0x23, 0x9e, 0xe5, 0x9c, 0x1d, 0x99, 0x17, 0x6c, 0xc0, 0x60, 0x41, 0x46, 0x79, 0x58,
	0xf1, 0x89, 0xe1, 0x11, 0x9d, 0x58, 0xb6, 0xa9, 0x07, 0x8e, 0xd5, 0xd3, 0x1d, 0xc3, 0x71, 0xd9,
	0x5c, 0x4d, 0xe2, 0x65, 0x96, 0xab, 0x5b, 0xb6, 0xd9, 0x70, 0xac, 0x5e, 0xc5, 0x70, 0x5c, 0x74,
	0x1f, 0x16, 0x47, 0xa0, 0x71, 0x06, 0x5d, 0x20, 0xc3, 0xa8, 0x0d, 0x98, 0xe7, 0xf3, 0xd6, 0x72,
	0xc8, 0xcb, 0x3d, 0x36, 0x70, 0xe3, 0x98, 0x8f, 0x60, 0x8d, 0x46, 0xd0, 0x16, 0x2c, 0x70, 0x40,
	0xdb, 0x0d, 0x9a, 0x1d, 0x93, 0x4d, 0x4f, 0x09, 0x73, 0x52, 0x81, 0x85, 0xd0, 0x21, 0xc8, 0xef,
	0x2d, 0x9f, 0xb8, 0x67, 0x9e, 0x61, 0x67, 0x92, 0x97, 0x7c, 0x63, 0x0c, 0x4d, 0xd7, 0xd7, 0x21,
	0x01, 0x0f, 0xb8, 0x48, 0x85, 0x94, 0x1f, 0xd8, 0x36, 0x7d, 0x55, 0xa7, 0x98, 0xcc, 0xc3, 0x59,
	0x32, 0x35, 0x0e, 0xc7, 0x21, 0x0f, 0x7d, 0x0d, 0xb2, 0xd9, 0x33, 0xed, 0x6e, 0xc7, 0xf0, 0xfc,
	0x4c, 0x9a, 0x19, 0xbe, 0x3d, 0x4b, 0x04, 0x1b, 0xdf, 0x73, 0xaf, 0x07, 0xd4, 0xec, 0xaf, 0x31,
	0x90, 0xfb, 0x35, 0xa2, 0x15, 0x98, 0x6b, 0xb9, 0x81, 0x43, 0xd8, 0x0b, 0x2e, 0x81, 0xf9, 0x05,
	0xba, 0x0b, 0xb2, 0x1f, 0xd8, 0xc2, 0xb9, 0x18, 0x73, 0x2e, 0xed, 0x07, 0x36, 0xf7, 0x6d, 0x0d,
	0x80, 0x26, 0x85, 0x6b, 0x71, 0xe6, 0x1a, 0x85, 0x0b, 0xcf, 0xde, 0x40, 0xaa, 0x19, 0xb4, 0x3e,
	0x98, 0xc4, 0xcf, 0x24, 0x59, 0x95, 0xcf, 0xaf, 0xec, 0x58, 0x6e, 0x9f, 0x11, 0x71, 0x28, 0x80,
	0x76, 0xe1, 0xa6, 0xd9, 0xeb, 0x76, 0xac, 0x96, 0x45, 0xf4, 0xa6, 0x1b, 0x38, 0x6d, 0x5f, 0xd4,
	0x94, 0xda, 0x8c, 0x6f, 0xc7, 0xf1, 0x8d, 0x30, 0xb9, 0xcf, 0x72, 0xbc, 0xbc, 0x3d, 0xb8, 0x35,
	0xca, 0x11, 0xa5, 0x52, 0xd3, 0x24, 0xbc, 0x12, 0x25, 0xf1, 0xaa, 0x57, 0xd7, 0x21, 0xc9, 0x37,
	0x9f, 0xec, 0x48, 0xf6, 0xef, 0x38, 0xa4, 0xc4, 0x2d, 0xf9, 0x0f, 0x3c, 0xbb, 0x0b, 0xb2, 0x6d,
	0x39, 0x91, 0x93, 0x9a, 0xb6, 0x2d, 0xa7, 0xcf, 0xa5, 0xc9, 0xc8, 0x29, 0xa5, 0xf0, 0x21, 0xae,
	0xd1, 0x13, 0xdc, 0xa4, 0xe0, 0x1a, 0xbd, 0x01, 0xd7, 0xe8, 0x85, 0xdc, 0x94, 0xe0, 0x1a, 0x3d,
	0xc1, 0x5d, 0x03, 0xe8, 0x18, 0x3e, 0x11, 0xe4, 0x34, 0x23, 0xcb, 0x34, 0xc2, 0xd9, 0x1b, 0x30,
	0xcf, 0xd2, 0x82, 0x2e, 0x33, 0x3a, 0x63, 0x08, 0xfe, 0x77, 0xb0, 0xf4, 0x31, 0x30, 0x1c, 0x62,
	0x75, 0x4c, 0x9d, 0x3d, 0x37, 0x7e, 0x06, 0xd8, 0x3d, 0xff, 0xfc, 0x8a, 0xc7, 0x9b, 0x7f, 0xcf,
	0xa8, 0xe4, 0xad, 0x50, 0xc1, 0x8b, 0xa1, 0x1e, 0x4b, 0xf8, 0xab, 0x1f, 0x61, 0x69, 0x04, 0x82,
	0x56, 0x21, 0x1d, 0x82, 0xd8, 0x1d, 0x90, 0x70, 0xff, 0x7a, 0xf4, 0xa1, 0x8f, 0xcd, 0x7c, 0xe8,
	0xe3, 0x63, 0x0f, 0x7d, 0xf6, 0xe7, 0x18, 0xa4, 0xc3, 0x07, 0x67, 0x0c, 0x2f, 0x8d, 0x0f, 0x89,
	0x99, 0x7b, 0x5e, 0x6d, 0x5e, 0xbd, 0x83, 0x65, 0xa3, 0xdd, 0xb6, 0xe8, 0xf7, 0xa3, 0xd1, 0xd1,
	0xc5, 0x60, 0x4d, 0xfc, 0x9b, 0xc1, 0xaa, 0x0c, 0x74, 0x4a, 0x7c, 0xc4, 0xde, 0x86, 0x94, 0xdf,
	0x35, 0x1c, 0xdd, 0xe2, 0xdf, 0x88, 0x0b, 0x38, 0x49, 0x2f, 0xb5, 0x36, 0xba, 0x03, 0x69, 0xe2,
	0x19, 0x2d, 0x93, 0x66, 0x92, 0x2c, 0x93, 0x62, 0xd7, 0x5a, 0x9b, 0x76, 0xee, 0x1b, 0x76, 0xb7,
	0x63, 0xea, 0xfc, 0xb0, 0xf3, 0xc3, 0x33, 0xcf, 0x63, 0x07, 0x34, 0xb4, 0x4f, 0x60, 0xcb, 0x72,
	0x67, 0xdc, 0xe9, 0xfd, 0x05, 0xf1, 0xfb, 0x72, 0x4c, 0x13, 0xc7, 0xd2, 0xbb, 0xaf, 0xce, 0x2c,
	0xf2, 0x3e, 0x68, 0xd2, 0xf2, 0xf3, 0x94, 0xfa, 0x6c, 0xf0, 0x1b, 0x18, 0x51, 0x7a, 0xc6, 0x7f,
	0x0a, 0xcf, 0x4c, 0x27, 0x7f, 0x36, 0xfc, 0x57, 0xda, 0x4c, 0xb2, 0xc4, 0x67, 0xff, 0x04, 0x00,
	0x00, 0xff, 0xff, 0x3b, 0x3c, 0x48, 0x57, 0xbe, 0x0e, 0x00, 0x00,
}
