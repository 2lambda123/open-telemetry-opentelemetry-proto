// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opentelemetry/proto/metrics/v1/metrics.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v11 "github.com/open-telemetry/opentelemetry-proto/gen/go/common/v1"
	v1 "github.com/open-telemetry/opentelemetry-proto/gen/go/resource/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type is the type of values this metric has.
type MetricDescriptor_Type int32

const (
	// UNDEFINED is the default Type, it MUST not be used.
	MetricDescriptor_UNDEFINED MetricDescriptor_Type = 0
	// INT64 values are represents as signed 64-bit integers.
	//
	// A Metric of this Type MUST assign values to the int64_value field in
	// its Data.
	MetricDescriptor_INT64 MetricDescriptor_Type = 1
	// DOUBLE values are represents as double-precision floating-point
	// numbers.
	//
	// A Metric of this Type MUST assign values to the double_value field
	// in its Data.
	MetricDescriptor_DOUBLE MetricDescriptor_Type = 2
	// DISTRIBUTION values are statistics for an observed population
	// represented. These statistics are represented as a Distribution
	// message.
	//
	// A Metric of this Type MUST assign values to the distribution_value
	// field in its Data.
	MetricDescriptor_DISTRIBUTION MetricDescriptor_Type = 3
)

var MetricDescriptor_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "INT64",
	2: "DOUBLE",
	3: "DISTRIBUTION",
}

var MetricDescriptor_Type_value = map[string]int32{
	"UNDEFINED":    0,
	"INT64":        1,
	"DOUBLE":       2,
	"DISTRIBUTION": 3,
}

func (x MetricDescriptor_Type) String() string {
	return proto.EnumName(MetricDescriptor_Type_name, int32(x))
}

func (MetricDescriptor_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 0}
}

// Temporality describes how metric values are reported over time.
type MetricDescriptor_Temporality int32

const (
	// UNSPECIFIED is the default Temporality, it MUST not be used.
	MetricDescriptor_UNSPECIFIED MetricDescriptor_Temporality = 0
	// INSTANTANEOUS is a metric whose values are measured at a particular
	// instant.
	//
	// If an INSTANTANEOUS metric is reported over any time interval the
	// values are representative of distinct measurements within the
	// interval.
	MetricDescriptor_INSTANTANEOUS MetricDescriptor_Temporality = 1
	// DELTA is a metric whose values are measured and successively
	// aggregated over a reporting interval. The reported value represents
	// the change from the previous interval.
	//
	// Each reported value for a DELTA metric over a time interval is
	// self-contained, the values do not depend on values in other time
	// intervals. This is unlike a CUMMULATIVE metric where values are sums
	// of all measured events in the time interval and all previously
	// measured values of the metric.
	//
	// DELTA metrics are not guaranteed to be monotonic.
	MetricDescriptor_DELTA MetricDescriptor_Temporality = 2
	// CUMULATIVE is a metric whose values are measured and successively
	// added to the lifetime total of the metric.
	//
	// Each reported value for a CUMULATIVE metric is the sum of all
	// measurements up to and including that one.
	//
	// CUMULATIVE metrics are not guaranteed to be monotonic.
	MetricDescriptor_CUMULATIVE MetricDescriptor_Temporality = 3
)

var MetricDescriptor_Temporality_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "INSTANTANEOUS",
	2: "DELTA",
	3: "CUMULATIVE",
}

var MetricDescriptor_Temporality_value = map[string]int32{
	"UNSPECIFIED":   0,
	"INSTANTANEOUS": 1,
	"DELTA":         2,
	"CUMULATIVE":    3,
}

func (x MetricDescriptor_Temporality) String() string {
	return proto.EnumName(MetricDescriptor_Temporality_name, int32(x))
}

func (MetricDescriptor_Temporality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 1}
}

// Monotonic describes the metric values to be entirely non-increasing,
// or entirely non-decreasing.
type MetricDescriptor_Monotonic int32

const (
	// UNKNOWN is the default, and means it the monotonic nature of the
	// metric values is known.
	MetricDescriptor_UNKNOWN MetricDescriptor_Monotonic = 0
	// NONDECREASING means all the successive metric values increase or
	// remain constant.
	MetricDescriptor_NONDECREASING MetricDescriptor_Monotonic = 1
)

var MetricDescriptor_Monotonic_name = map[int32]string{
	0: "UNKNOWN",
	1: "NONDECREASING",
}

var MetricDescriptor_Monotonic_value = map[string]int32{
	"UNKNOWN":       0,
	"NONDECREASING": 1,
}

func (x MetricDescriptor_Monotonic) String() string {
	return proto.EnumName(MetricDescriptor_Monotonic_name, int32(x))
}

func (MetricDescriptor_Monotonic) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 2}
}

// Domain describes the set of numbers metric values belong to if any.
type MetricDescriptor_Domain int32

const (
	// NONE is the default, and means the metric values do not belong to any
	// particular domain other than the value type itself.
	MetricDescriptor_NONE MetricDescriptor_Domain = 0
	// NONNEGATIVE is the set of numbers greater than or equal to zero.
	MetricDescriptor_NONNEGATIVE MetricDescriptor_Domain = 1
)

var MetricDescriptor_Domain_name = map[int32]string{
	0: "NONE",
	1: "NONNEGATIVE",
}

var MetricDescriptor_Domain_value = map[string]int32{
	"NONE":        0,
	"NONNEGATIVE": 1,
}

func (x MetricDescriptor_Domain) String() string {
	return proto.EnumName(MetricDescriptor_Domain_name, int32(x))
}

func (MetricDescriptor_Domain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 3}
}

// A collection of InstrumentationLibraryMetrics from a Resource.
type ResourceMetrics struct {
	// The resource for the metrics in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of metrics that originate from a resource.
	InstrumentationLibraryMetrics []*InstrumentationLibraryMetrics `protobuf:"bytes,2,rep,name=instrumentation_library_metrics,json=instrumentationLibraryMetrics,proto3" json:"instrumentation_library_metrics,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                         `json:"-"`
	XXX_unrecognized              []byte                           `json:"-"`
	XXX_sizecache                 int32                            `json:"-"`
}

func (m *ResourceMetrics) Reset()         { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()    {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{0}
}

func (m *ResourceMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceMetrics.Unmarshal(m, b)
}
func (m *ResourceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceMetrics.Marshal(b, m, deterministic)
}
func (m *ResourceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMetrics.Merge(m, src)
}
func (m *ResourceMetrics) XXX_Size() int {
	return xxx_messageInfo_ResourceMetrics.Size(m)
}
func (m *ResourceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMetrics proto.InternalMessageInfo

func (m *ResourceMetrics) GetResource() *v1.Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceMetrics) GetInstrumentationLibraryMetrics() []*InstrumentationLibraryMetrics {
	if m != nil {
		return m.InstrumentationLibraryMetrics
	}
	return nil
}

// A collection of Metrics produced by an InstrumentationLibrary.
type InstrumentationLibraryMetrics struct {
	// The instrumentation library information for the metrics in this message.
	// If this field is not set then no library info is known.
	InstrumentationLibrary *v11.InstrumentationLibrary `protobuf:"bytes,1,opt,name=instrumentation_library,json=instrumentationLibrary,proto3" json:"instrumentation_library,omitempty"`
	// A list of metrics that originate from an instrumentation library.
	Metrics              []*Metric `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstrumentationLibraryMetrics) Reset()         { *m = InstrumentationLibraryMetrics{} }
func (m *InstrumentationLibraryMetrics) String() string { return proto.CompactTextString(m) }
func (*InstrumentationLibraryMetrics) ProtoMessage()    {}
func (*InstrumentationLibraryMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{1}
}

func (m *InstrumentationLibraryMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Unmarshal(m, b)
}
func (m *InstrumentationLibraryMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Marshal(b, m, deterministic)
}
func (m *InstrumentationLibraryMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstrumentationLibraryMetrics.Merge(m, src)
}
func (m *InstrumentationLibraryMetrics) XXX_Size() int {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Size(m)
}
func (m *InstrumentationLibraryMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_InstrumentationLibraryMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_InstrumentationLibraryMetrics proto.InternalMessageInfo

func (m *InstrumentationLibraryMetrics) GetInstrumentationLibrary() *v11.InstrumentationLibrary {
	if m != nil {
		return m.InstrumentationLibrary
	}
	return nil
}

func (m *InstrumentationLibraryMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Metric represents a timeseries produced by a telemetry system.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a list of label keys (shown horizontally).
// - Data is a list of DataPoints (shown vertically).
// - DataPoint contains a list of label values and a value.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         |+-----+-----+   +-----+ |
//  |          |         ||label|label|...|label| |
//  |      data|--+      ||key1 |key2 |   |keyN | |
//  +----------+  |      |+-----+-----+   +-----+ |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
type Metric struct {
	// metric_descriptor describing this Metric.
	MetricDescriptor *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor,proto3" json:"metric_descriptor,omitempty"`
	// start_time_unix_nano is the beginning of the time interval over which
	// all data for this Metric were recorded. It MUST be represented as the
	// UNIX Epoch time in nanoseconds (nanoseconds since 00:00:00 UTC on 1
	// January 1970). If zero, it is treated as unspecified.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// end_time_unix_nano is the end of the time interval over which all data
	// for this Metric were recorded. It MUST be represented as the UNIX Epoch
	// time in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970).
	// If zero, it is treated as unspecified and the end to the time interval
	// is define by the receiver as the time this data is received. It is
	// RECOMMENDED to not leave this unspecified.
	EndTimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// Data values of this Metric.
	Data                 []*Metric_Data `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Metric) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Metric) GetData() []*Metric_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type Metric_Data struct {
	// The set of additional labels uniquely identifying this data.
	//
	// It is considered an error for Labels used here to have the same key
	// as those defined in this Metric's MetricDescriptor and MUST be
	// avoided. The handling of this error is left up to the receiver.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the beginning of the time interval over which
	// this data was recorded. It MUST be represented as the UNIX Epoch time
	// in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
	// zero, it is treated as unspecified.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// end_time_unix_nano is the end of the time interval over which this
	// data was recorded. It MUST be represented as the UNIX Epoch time in
	// nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
	// zero, it is treated as unspecified.
	EndTimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// int64_value contains the measured value for INT64 type Metrics.
	Int64Value int64 `protobuf:"varint,4,opt,name=int64_value,json=int64Value,proto3" json:"int64_value,omitempty"`
	// double_value contains the measured value for DOUBLE type Metrics.
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue,proto3" json:"double_value,omitempty"`
	// distribution_value contains the measured value for DISTRIBUTION type
	// Metrics.
	DistributionValue    *Distribution `protobuf:"bytes,6,opt,name=distribution_value,json=distributionValue,proto3" json:"distribution_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metric_Data) Reset()         { *m = Metric_Data{} }
func (m *Metric_Data) String() string { return proto.CompactTextString(m) }
func (*Metric_Data) ProtoMessage()    {}
func (*Metric_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2, 0}
}

func (m *Metric_Data) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric_Data.Unmarshal(m, b)
}
func (m *Metric_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric_Data.Marshal(b, m, deterministic)
}
func (m *Metric_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric_Data.Merge(m, src)
}
func (m *Metric_Data) XXX_Size() int {
	return xxx_messageInfo_Metric_Data.Size(m)
}
func (m *Metric_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Metric_Data proto.InternalMessageInfo

func (m *Metric_Data) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric_Data) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Metric_Data) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Metric_Data) GetInt64Value() int64 {
	if m != nil {
		return m.Int64Value
	}
	return 0
}

func (m *Metric_Data) GetDoubleValue() float64 {
	if m != nil {
		return m.DoubleValue
	}
	return 0
}

func (m *Metric_Data) GetDistributionValue() *Distribution {
	if m != nil {
		return m.DistributionValue
	}
	return nil
}

// MetricDescriptor describes the identifying attributes of a metric.
type MetricDescriptor struct {
	// name of the metric.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description of the metric.
	//
	// This description is commonly used in documentation so it should be a
	// human-readable explanation of the metric.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit        string                       `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	Type        MetricDescriptor_Type        `protobuf:"varint,4,opt,name=type,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Type" json:"type,omitempty"`
	Temporality MetricDescriptor_Temporality `protobuf:"varint,5,opt,name=temporality,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality" json:"temporality,omitempty"`
	Monotonic   MetricDescriptor_Monotonic   `protobuf:"varint,6,opt,name=monotonic,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Monotonic" json:"monotonic,omitempty"`
	Domain      MetricDescriptor_Domain      `protobuf:"varint,7,opt,name=domain,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Domain" json:"domain,omitempty"`
	// The set of labels associated with the metric descriptor. Labels in this
	// list apply to all data points.
	Labels               []*v11.StringKeyValue `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetricDescriptor) Reset()         { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()    {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3}
}

func (m *MetricDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricDescriptor.Unmarshal(m, b)
}
func (m *MetricDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricDescriptor.Marshal(b, m, deterministic)
}
func (m *MetricDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDescriptor.Merge(m, src)
}
func (m *MetricDescriptor) XXX_Size() int {
	return xxx_messageInfo_MetricDescriptor.Size(m)
}
func (m *MetricDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDescriptor proto.InternalMessageInfo

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetType() MetricDescriptor_Type {
	if m != nil {
		return m.Type
	}
	return MetricDescriptor_UNDEFINED
}

func (m *MetricDescriptor) GetTemporality() MetricDescriptor_Temporality {
	if m != nil {
		return m.Temporality
	}
	return MetricDescriptor_UNSPECIFIED
}

func (m *MetricDescriptor) GetMonotonic() MetricDescriptor_Monotonic {
	if m != nil {
		return m.Monotonic
	}
	return MetricDescriptor_UNKNOWN
}

func (m *MetricDescriptor) GetDomain() MetricDescriptor_Domain {
	if m != nil {
		return m.Domain
	}
	return MetricDescriptor_NONE
}

func (m *MetricDescriptor) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Distribution is a data point in a timeseries containing statistics for
// an observed population of values.
type Distribution struct {
	// count is the number of values in a population.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// sum is the total sum of all values in a population.
	Sum float64 `protobuf:"fixed64,2,opt,name=sum,proto3" json:"sum,omitempty"`
	// minimum is the minimum observed value in a population.
	Minimum float64 `protobuf:"fixed64,3,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// maximum is the maximum observed value in a population.
	Maximum float64 `protobuf:"fixed64,4,opt,name=maximum,proto3" json:"maximum,omitempty"`
	// buckets is an optional field contains the values of histogram for each bucket.
	//
	// The sum of the values in the buckets "count" field must equal the value in the count field.
	//
	// The number of elements in buckets array must be by one greater than the
	// number of elements in bucket_bounds array.
	//
	// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
	// must also be present and number of elements in this field must be equal to the
	// number of buckets defined by bucket_options.
	Buckets []*Distribution_Bucket `protobuf:"bytes,5,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// explicit_bounds specifies buckets with explicitly defined bounds for values.
	// The bucket boundaries are described by "bounds" field.
	//
	// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
	// at index i are:
	//
	// [0, bounds[i]) for i == 0
	// [bounds[i-1], bounds[i]) for 0 < i < N-1
	// [bounds[i], +infinity) for i == N-1
	// The values in bounds array must be strictly increasing and > 0.
	//
	// Note: only [a, b) intervals are currently supported for each bucket. If we decides
	// to also support (a, b] intervals we should add support for these by defining a boolean
	// value which decides what type of intervals to use.
	ExplicitBounds       []float64 `protobuf:"fixed64,6,rep,packed,name=explicit_bounds,json=explicitBounds,proto3" json:"explicit_bounds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Distribution) Reset()         { *m = Distribution{} }
func (m *Distribution) String() string { return proto.CompactTextString(m) }
func (*Distribution) ProtoMessage()    {}
func (*Distribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4}
}

func (m *Distribution) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution.Unmarshal(m, b)
}
func (m *Distribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution.Marshal(b, m, deterministic)
}
func (m *Distribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution.Merge(m, src)
}
func (m *Distribution) XXX_Size() int {
	return xxx_messageInfo_Distribution.Size(m)
}
func (m *Distribution) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution proto.InternalMessageInfo

func (m *Distribution) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Distribution) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Distribution) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Distribution) GetBuckets() []*Distribution_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Distribution) GetExplicitBounds() []float64 {
	if m != nil {
		return m.ExplicitBounds
	}
	return nil
}

// Bucket contains values for a bucket.
type Distribution_Bucket struct {
	// The number of values in each bucket of the histogram, as described by
	// bucket_options.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// exemplar is an optional representative value of the bucket.
	Exemplar             *Distribution_Bucket_Exemplar `protobuf:"bytes,2,opt,name=exemplar,proto3" json:"exemplar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Distribution_Bucket) Reset()         { *m = Distribution_Bucket{} }
func (m *Distribution_Bucket) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket) ProtoMessage()    {}
func (*Distribution_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0}
}

func (m *Distribution_Bucket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket.Unmarshal(m, b)
}
func (m *Distribution_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket.Merge(m, src)
}
func (m *Distribution_Bucket) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket.Size(m)
}
func (m *Distribution_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket proto.InternalMessageInfo

func (m *Distribution_Bucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution_Bucket) GetExemplar() *Distribution_Bucket_Exemplar {
	if m != nil {
		return m.Exemplar
	}
	return nil
}

// Exemplars are example points that may be used to annotate aggregated
// Histogram values. They are metadata that gives information about a
// particular value added to a Histogram bucket.
type Distribution_Bucket_Exemplar struct {
	// Value of the exemplar point. It determines which bucket the exemplar belongs to.
	// If bucket_options define bounds for this bucket then this value must be within
	// the defined bounds.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// end_time_unix_nano is the moment when this exemplar was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	EndTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// exemplar_attachments are contextual information about the example value.
	// Keys in this list must be unique.
	Attachments          []*v11.StringKeyValue `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Distribution_Bucket_Exemplar) Reset()         { *m = Distribution_Bucket_Exemplar{} }
func (m *Distribution_Bucket_Exemplar) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket_Exemplar) ProtoMessage()    {}
func (*Distribution_Bucket_Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0, 0}
}

func (m *Distribution_Bucket_Exemplar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Unmarshal(m, b)
}
func (m *Distribution_Bucket_Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket_Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket_Exemplar.Merge(m, src)
}
func (m *Distribution_Bucket_Exemplar) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Size(m)
}
func (m *Distribution_Bucket_Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket_Exemplar proto.InternalMessageInfo

func (m *Distribution_Bucket_Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetAttachments() []*v11.StringKeyValue {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Type", MetricDescriptor_Type_name, MetricDescriptor_Type_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality", MetricDescriptor_Temporality_name, MetricDescriptor_Temporality_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Monotonic", MetricDescriptor_Monotonic_name, MetricDescriptor_Monotonic_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Domain", MetricDescriptor_Domain_name, MetricDescriptor_Domain_value)
	proto.RegisterType((*ResourceMetrics)(nil), "opentelemetry.proto.metrics.v1.ResourceMetrics")
	proto.RegisterType((*InstrumentationLibraryMetrics)(nil), "opentelemetry.proto.metrics.v1.InstrumentationLibraryMetrics")
	proto.RegisterType((*Metric)(nil), "opentelemetry.proto.metrics.v1.Metric")
	proto.RegisterType((*Metric_Data)(nil), "opentelemetry.proto.metrics.v1.Metric.Data")
	proto.RegisterType((*MetricDescriptor)(nil), "opentelemetry.proto.metrics.v1.MetricDescriptor")
	proto.RegisterType((*Distribution)(nil), "opentelemetry.proto.metrics.v1.Distribution")
	proto.RegisterType((*Distribution_Bucket)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket")
	proto.RegisterType((*Distribution_Bucket_Exemplar)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket.Exemplar")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/metrics/v1/metrics.proto", fileDescriptor_3c3112f9fa006917)
}

var fileDescriptor_3c3112f9fa006917 = []byte{
	// 991 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xc7, 0x3b, 0xf6, 0xc6, 0x89, 0xcf, 0xa6, 0xc9, 0x66, 0x54, 0xc1, 0x2a, 0x52, 0xa9, 0x6b,
	0x24, 0x30, 0xa4, 0x59, 0x93, 0xb4, 0x14, 0x09, 0x01, 0x25, 0x8e, 0xb7, 0xd5, 0xaa, 0xc9, 0x38,
	0x1a, 0xdb, 0xa5, 0x02, 0x81, 0xb5, 0xb6, 0x47, 0xe9, 0x08, 0xef, 0x8c, 0xb5, 0x3b, 0x1b, 0xc5,
	0x0f, 0xc0, 0x43, 0x70, 0xc3, 0x13, 0x71, 0xc3, 0x05, 0x17, 0xdc, 0xf1, 0x24, 0x08, 0xed, 0xcc,
	0x6e, 0xe2, 0x44, 0x4e, 0xd2, 0x80, 0x7a, 0x37, 0x73, 0x3e, 0x7e, 0x73, 0xce, 0xdf, 0x67, 0xc7,
	0x03, 0x8f, 0xe4, 0x94, 0x09, 0xc5, 0x26, 0x2c, 0x62, 0x2a, 0x9e, 0x35, 0xa7, 0xb1, 0x54, 0xb2,
	0x99, 0xad, 0xf9, 0x28, 0x69, 0x9e, 0xec, 0x14, 0x4b, 0x4f, 0x3b, 0xf0, 0x07, 0x17, 0xa2, 0x8d,
	0xd1, 0x2b, 0x42, 0x4e, 0x76, 0x36, 0x3f, 0x5d, 0x44, 0x1b, 0xc9, 0x28, 0x92, 0x22, 0x83, 0x99,
	0x95, 0x49, 0xdb, 0xf4, 0x16, 0xc5, 0xc6, 0x2c, 0x91, 0x69, 0x3c, 0x62, 0x59, 0x74, 0xb1, 0x36,
	0xf1, 0xf5, 0xbf, 0x11, 0xac, 0xd3, 0xdc, 0x74, 0x68, 0x8e, 0xc4, 0x3e, 0xac, 0x14, 0x51, 0x2e,
	0xaa, 0xa1, 0x86, 0xbd, 0xfb, 0x89, 0xb7, 0xa8, 0xc4, 0x33, 0xd4, 0xc9, 0x8e, 0x57, 0x30, 0xe8,
	0x59, 0x2a, 0xfe, 0x05, 0xc1, 0x03, 0x2e, 0x12, 0x15, 0xa7, 0x11, 0x13, 0x2a, 0x54, 0x5c, 0x8a,
	0xc1, 0x84, 0x0f, 0xe3, 0x30, 0x9e, 0x0d, 0xf2, 0xee, 0xdc, 0x52, 0xad, 0xdc, 0xb0, 0x77, 0xbf,
	0xf6, 0xae, 0x57, 0xc0, 0x0b, 0x2e, 0x62, 0x0e, 0x0c, 0x25, 0xaf, 0x97, 0xde, 0xe7, 0xd7, 0xb9,
	0xeb, 0x7f, 0x20, 0xb8, 0x7f, 0x2d, 0x00, 0x0b, 0x78, 0xff, 0x8a, 0x42, 0xf3, 0xfe, 0x3f, 0x5f,
	0x58, 0x60, 0x2e, 0xfc, 0x95, 0xf5, 0xd1, 0xf7, 0x16, 0x17, 0x86, 0xbf, 0x85, 0xe5, 0x8b, 0x02,
	0x7c, 0x74, 0x93, 0x00, 0xa6, 0x52, 0x5a, 0xa4, 0xd5, 0xff, 0xb4, 0xa0, 0x62, 0x6c, 0xf8, 0x47,
	0xd8, 0x30, 0xd6, 0xc1, 0x98, 0x25, 0xa3, 0x98, 0x4f, 0x95, 0x8c, 0xf3, 0xb2, 0x3f, 0x7b, 0x3b,
	0x6c, 0xfb, 0x2c, 0x8f, 0x3a, 0xd1, 0x25, 0x0b, 0x6e, 0xc2, 0xbd, 0x44, 0x85, 0xb1, 0x1a, 0x28,
	0x1e, 0xb1, 0x41, 0x2a, 0xf8, 0xe9, 0x40, 0x84, 0x42, 0xba, 0xa5, 0x1a, 0x6a, 0x54, 0xe8, 0x86,
	0xf6, 0xf5, 0x78, 0xc4, 0xfa, 0x82, 0x9f, 0x92, 0x50, 0x48, 0xbc, 0x05, 0x98, 0x89, 0xf1, 0xe5,
	0xf0, 0xb2, 0x0e, 0x5f, 0x67, 0x62, 0x7c, 0x21, 0xf8, 0x19, 0x58, 0xe3, 0x50, 0x85, 0xae, 0xa5,
	0x65, 0xd8, 0x7a, 0xbb, 0x7a, 0xbd, 0x76, 0xa8, 0x42, 0xaa, 0x13, 0x37, 0x7f, 0x2f, 0x81, 0x95,
	0x6d, 0xb1, 0x0f, 0x95, 0x49, 0x38, 0x64, 0x93, 0xc4, 0x45, 0x9a, 0xb5, 0x7d, 0xc3, 0x4f, 0xd6,
	0x55, 0x31, 0x17, 0xc7, 0x2f, 0xd9, 0xec, 0x55, 0x38, 0x49, 0x19, 0xcd, 0x93, 0xdf, 0x71, 0xbb,
	0x0f, 0xc0, 0xe6, 0x42, 0x3d, 0x7d, 0x32, 0x38, 0xc9, 0x0e, 0x75, 0xad, 0x1a, 0x6a, 0x94, 0x29,
	0x68, 0x93, 0x2e, 0x03, 0x3f, 0x84, 0xd5, 0xb1, 0x4c, 0x87, 0x13, 0x96, 0x47, 0x2c, 0xd5, 0x50,
	0x03, 0x51, 0xdb, 0xd8, 0x4c, 0xc8, 0x0f, 0x80, 0xc7, 0x3c, 0x51, 0x31, 0x1f, 0xa6, 0x7a, 0x52,
	0x4d, 0x60, 0x45, 0xff, 0xe0, 0x8f, 0x6e, 0x12, 0xb0, 0x3d, 0x97, 0x49, 0x37, 0xe6, 0x39, 0x1a,
	0x5e, 0xff, 0x6b, 0x09, 0x9c, 0xcb, 0x43, 0x81, 0x31, 0x58, 0x22, 0x8c, 0xcc, 0x5d, 0x50, 0xa5,
	0x7a, 0x8d, 0x6b, 0x60, 0x17, 0xe3, 0xc6, 0xa5, 0xd0, 0xf2, 0x54, 0xe9, 0xbc, 0x29, 0xcb, 0x4a,
	0x05, 0x57, 0x5a, 0x8a, 0x2a, 0xd5, 0x6b, 0x1c, 0x80, 0xa5, 0x66, 0x53, 0xd3, 0xf8, 0xda, 0x15,
	0x5f, 0xd5, 0x35, 0xe3, 0xe9, 0xf5, 0x66, 0x53, 0x46, 0x35, 0x02, 0xff, 0x04, 0xb6, 0x62, 0xd1,
	0x54, 0xc6, 0xe1, 0x84, 0xab, 0x99, 0x16, 0x6a, 0x6d, 0xf7, 0xab, 0xdb, 0x13, 0xcf, 0x19, 0x74,
	0x1e, 0x88, 0x5f, 0x43, 0x35, 0x92, 0x42, 0x2a, 0x29, 0xf8, 0x48, 0xab, 0xbb, 0xb6, 0xfb, 0xe5,
	0xad, 0xe9, 0x87, 0x05, 0x81, 0x9e, 0xc3, 0x70, 0x07, 0x2a, 0x63, 0x19, 0x85, 0x5c, 0xb8, 0xcb,
	0x1a, 0xfb, 0xc5, 0xad, 0xb1, 0x6d, 0x9d, 0x4e, 0x73, 0xcc, 0xdc, 0xe8, 0xaf, 0xfc, 0x8f, 0xd1,
	0xaf, 0x7f, 0x03, 0x56, 0xa6, 0x2f, 0xbe, 0x0b, 0xd5, 0x3e, 0x69, 0xfb, 0xcf, 0x03, 0xe2, 0xb7,
	0x9d, 0x3b, 0xb8, 0x0a, 0x4b, 0x01, 0xe9, 0x3d, 0x7d, 0xe2, 0x20, 0x0c, 0x50, 0x69, 0x77, 0xfa,
	0xad, 0x03, 0xdf, 0x29, 0x61, 0x07, 0x56, 0xdb, 0x41, 0xb7, 0x47, 0x83, 0x56, 0xbf, 0x17, 0x74,
	0x88, 0x53, 0xae, 0x1f, 0x80, 0x3d, 0xa7, 0x26, 0x5e, 0x07, 0xbb, 0x4f, 0xba, 0x47, 0xfe, 0x7e,
	0xf0, 0x3c, 0xd0, 0xa0, 0x0d, 0xb8, 0x1b, 0x90, 0x6e, 0x6f, 0x8f, 0xf4, 0xf6, 0x88, 0xdf, 0xe9,
	0x77, 0x1d, 0x94, 0xb1, 0xdb, 0xfe, 0x41, 0x6f, 0xcf, 0x29, 0xe1, 0x35, 0x80, 0xfd, 0xfe, 0x61,
	0xff, 0x60, 0xaf, 0x17, 0xbc, 0xf2, 0x9d, 0x72, 0x7d, 0x0b, 0xaa, 0x67, 0xea, 0x61, 0x1b, 0x96,
	0xfb, 0xe4, 0x25, 0xe9, 0x7c, 0x47, 0x0c, 0x87, 0x74, 0x48, 0xdb, 0xdf, 0xa7, 0xfe, 0x5e, 0x37,
	0x20, 0x2f, 0x1c, 0x54, 0xff, 0x10, 0x2a, 0x46, 0x13, 0xbc, 0x02, 0x16, 0xe9, 0x10, 0xdf, 0xb9,
	0x93, 0x9d, 0x4f, 0x3a, 0x84, 0xf8, 0x2f, 0x0c, 0x11, 0xd5, 0xff, 0x29, 0xc3, 0xea, 0xfc, 0xfc,
	0xe3, 0x7b, 0xb0, 0x34, 0x92, 0xa9, 0x50, 0x7a, 0xb0, 0x2d, 0x6a, 0x36, 0xd8, 0x81, 0x72, 0x92,
	0x46, 0x7a, 0xa2, 0x11, 0xcd, 0x96, 0xd8, 0x85, 0xe5, 0x88, 0x0b, 0x1e, 0xa5, 0x91, 0x1e, 0x66,
	0x44, 0x8b, 0xad, 0xf6, 0x84, 0xa7, 0xda, 0x63, 0xe5, 0x1e, 0xb3, 0xc5, 0x87, 0xb0, 0x3c, 0x4c,
	0x47, 0x3f, 0x33, 0x95, 0xb8, 0x4b, 0xfa, 0x47, 0x79, 0x7c, 0x9b, 0x4f, 0xd3, 0x6b, 0xe9, 0x5c,
	0x5a, 0x30, 0xf0, 0xc7, 0xb0, 0xce, 0x4e, 0xa7, 0x13, 0x3e, 0xe2, 0x6a, 0x30, 0x94, 0xa9, 0x18,
	0x27, 0x6e, 0xa5, 0x56, 0x6e, 0x20, 0xba, 0x56, 0x98, 0x5b, 0xda, 0xba, 0xf9, 0x6b, 0x09, 0x2a,
	0x26, 0xf9, 0x8a, 0xf6, 0x5e, 0xc3, 0x0a, 0x3b, 0x65, 0xd1, 0x74, 0x12, 0xc6, 0xba, 0x47, 0xfb,
	0xe6, 0x8f, 0x66, 0x41, 0x65, 0x9e, 0x9f, 0x33, 0xe8, 0x19, 0x6d, 0xf3, 0x37, 0x04, 0x2b, 0x85,
	0x39, 0x3b, 0xdc, 0x5c, 0x4c, 0x48, 0xeb, 0x62, 0x36, 0x57, 0x5c, 0x96, 0xa5, 0xc5, 0x97, 0x65,
	0x07, 0xec, 0x50, 0xa9, 0x70, 0xf4, 0x26, 0xfb, 0xff, 0x4c, 0xdc, 0xf2, 0x7f, 0x99, 0xed, 0x79,
	0x42, 0x4b, 0xc1, 0x43, 0x2e, 0x6f, 0x68, 0xb6, 0xb5, 0x9a, 0x3f, 0x0a, 0x8e, 0x32, 0xc7, 0x11,
	0xfa, 0xfe, 0xd9, 0x31, 0x57, 0x6f, 0xd2, 0x61, 0x76, 0x44, 0x33, 0x4b, 0xdd, 0x3e, 0x7f, 0x5c,
	0x5d, 0x20, 0x6d, 0x9b, 0xa7, 0xd6, 0x31, 0x13, 0xcd, 0xe3, 0xf9, 0xb7, 0xde, 0xb0, 0xa2, 0x1d,
	0x8f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x48, 0x44, 0xc1, 0xbc, 0x14, 0x0a, 0x00, 0x00,
}
