// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opentelemetry/proto/metrics/v1/metrics.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	v11 "github.com/open-telemetry/opentelemetry-proto/gen/go/common/v1"
	v1 "github.com/open-telemetry/opentelemetry-proto/gen/go/resource/v1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Temporality describes how metric values are reported over time.
type MetricDescriptor_Temporality int32

const (
	// UNSPECIFIED is the default Temporality, it MUST not be used.
	MetricDescriptor_UNSPECIFIED MetricDescriptor_Temporality = 0
	// INSTANTANEOUS is a metric whose values are measured at a particular
	// instant.
	//
	// If an INSTANTANEOUS metric is reported over any time interval the
	// values are representative of distinct measurements within the
	// interval.
	MetricDescriptor_INSTANTANEOUS MetricDescriptor_Temporality = 1
	// DELTA is a metric whose values are measured and successively
	// aggregated over a reporting interval. The reported value represents
	// the change from the previous interval.
	//
	// Each reported value for a DELTA metric over a time interval is
	// self-contained, the values do not depend on values in other time
	// intervals. This is unlike a CUMMULATIVE metric where values are sums
	// of all measured events in the time interval and all previously
	// measured values of the metric.
	//
	// DELTA metrics are not guaranteed to be monotonic.
	MetricDescriptor_DELTA MetricDescriptor_Temporality = 2
	// CUMULATIVE is a metric whose values are measured and successively
	// added to the lifetime total of the metric.
	//
	// Each reported value for a CUMULATIVE metric is the sum of all
	// measurements up to and including that one.
	//
	// CUMULATIVE metrics are not guaranteed to be monotonic.
	MetricDescriptor_CUMULATIVE MetricDescriptor_Temporality = 3
)

var MetricDescriptor_Temporality_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "INSTANTANEOUS",
	2: "DELTA",
	3: "CUMULATIVE",
}

var MetricDescriptor_Temporality_value = map[string]int32{
	"UNSPECIFIED":   0,
	"INSTANTANEOUS": 1,
	"DELTA":         2,
	"CUMULATIVE":    3,
}

func (x MetricDescriptor_Temporality) String() string {
	return proto.EnumName(MetricDescriptor_Temporality_name, int32(x))
}

func (MetricDescriptor_Temporality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 0}
}

// Domain describes the set of numbers metric values belong to if any.
type MetricDescriptor_Domain int32

const (
	// NONE is the default, and means the metric values do not belong to any
	// particular domain other than the value type itself.
	MetricDescriptor_NONE MetricDescriptor_Domain = 0
	// NONNEGATIVE is the set of numbers greater than or equal to zero.
	MetricDescriptor_NONNEGATIVE MetricDescriptor_Domain = 1
	// NONPOSITIVE is the set of numbers less than or equal to zero.
	MetricDescriptor_NONPOSITIVE MetricDescriptor_Domain = 2
)

var MetricDescriptor_Domain_name = map[int32]string{
	0: "NONE",
	1: "NONNEGATIVE",
	2: "NONPOSITIVE",
}

var MetricDescriptor_Domain_value = map[string]int32{
	"NONE":        0,
	"NONNEGATIVE": 1,
	"NONPOSITIVE": 2,
}

func (x MetricDescriptor_Domain) String() string {
	return proto.EnumName(MetricDescriptor_Domain_name, int32(x))
}

func (MetricDescriptor_Domain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3, 1}
}

// A collection of InstrumentationLibraryMetrics from a Resource.
type ResourceMetrics struct {
	// The resource for the metrics in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of metrics that originate from a resource.
	InstrumentationLibraryMetrics []*InstrumentationLibraryMetrics `protobuf:"bytes,2,rep,name=instrumentation_library_metrics,json=instrumentationLibraryMetrics,proto3" json:"instrumentation_library_metrics,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}                         `json:"-"`
	XXX_unrecognized              []byte                           `json:"-"`
	XXX_sizecache                 int32                            `json:"-"`
}

func (m *ResourceMetrics) Reset()         { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()    {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{0}
}

func (m *ResourceMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceMetrics.Unmarshal(m, b)
}
func (m *ResourceMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceMetrics.Marshal(b, m, deterministic)
}
func (m *ResourceMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMetrics.Merge(m, src)
}
func (m *ResourceMetrics) XXX_Size() int {
	return xxx_messageInfo_ResourceMetrics.Size(m)
}
func (m *ResourceMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMetrics proto.InternalMessageInfo

func (m *ResourceMetrics) GetResource() *v1.Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceMetrics) GetInstrumentationLibraryMetrics() []*InstrumentationLibraryMetrics {
	if m != nil {
		return m.InstrumentationLibraryMetrics
	}
	return nil
}

// A collection of Metrics produced by an InstrumentationLibrary.
type InstrumentationLibraryMetrics struct {
	// The instrumentation library information for the metrics in this message.
	// If this field is not set then no library info is known.
	InstrumentationLibrary *v11.InstrumentationLibrary `protobuf:"bytes,1,opt,name=instrumentation_library,json=instrumentationLibrary,proto3" json:"instrumentation_library,omitempty"`
	// A list of metrics that originate from an instrumentation library.
	Metrics              []*Metric `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InstrumentationLibraryMetrics) Reset()         { *m = InstrumentationLibraryMetrics{} }
func (m *InstrumentationLibraryMetrics) String() string { return proto.CompactTextString(m) }
func (*InstrumentationLibraryMetrics) ProtoMessage()    {}
func (*InstrumentationLibraryMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{1}
}

func (m *InstrumentationLibraryMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Unmarshal(m, b)
}
func (m *InstrumentationLibraryMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Marshal(b, m, deterministic)
}
func (m *InstrumentationLibraryMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstrumentationLibraryMetrics.Merge(m, src)
}
func (m *InstrumentationLibraryMetrics) XXX_Size() int {
	return xxx_messageInfo_InstrumentationLibraryMetrics.Size(m)
}
func (m *InstrumentationLibraryMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_InstrumentationLibraryMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_InstrumentationLibraryMetrics proto.InternalMessageInfo

func (m *InstrumentationLibraryMetrics) GetInstrumentationLibrary() *v11.InstrumentationLibrary {
	if m != nil {
		return m.InstrumentationLibrary
	}
	return nil
}

func (m *InstrumentationLibraryMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Metric represents a timeseries produced by a telemetry system.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a list of label keys (shown horizontally).
// - Data is a list of DataPoints (shown vertically).
// - DataPoint contains a list of label values and a value.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         |+-----+-----+   +-----+ |
//  |          |         ||label|label|...|label| |
//  |      data|--+      ||key1 |key2 |   |keyN | |
//  +----------+  |      |+-----+-----+   +-----+ |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
type Metric struct {
	// metric_descriptor describes the Metric.
	MetricDescriptor     *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor,proto3" json:"metric_descriptor,omitempty"`
	Data                 []*Metric_Data    `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetData() []*Metric_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type Metric_Data struct {
	// The set of labels that uniquely identify this timeseries.
	//
	// These labels take precedence over any labels with the same key defined
	// in the metric descriptor.
	Labels []*v11.StringKeyValue `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	// start_time_unix_nano is the beginning of a time interval over which
	// this data point was recorded. It MUST be represented as the UNIX Epoch
	// time in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970).
	// If zero, it is treated as unspecified and may be set by the receiver.
	//
	// If this data point is a part of a timeseries for an INSTANTANEOUS
	// metric, this value is ignored.
	//
	// If this data point is a part of a timeseries for a DELTA, or
	// CUMULATIVE metric, this value represents the instant before the
	// measuring time interval began (i.e. for time t to be in the measuring
	// interval than start_time_unix_nano < t <= time_unix_nano).
	//
	// This time MUST be reset so as to represent a new measurement lifetime
	// if this data point is part of a timeseries for a CUMULATIVE metric and
	// the metric value is reset to zero.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// time_unix_nano is the time when this data point was recorded. It MUST
	// be represented as the UNIX Epoch time in nanoseconds (nanoseconds since
	// 00:00:00 UTC on 1 January 1970). If zero, it is treated as unspecified
	// and may be set by the receiver.
	TimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// Value is the measured value.
	//
	// Types that are valid to be assigned to Value:
	//	*Metric_Data_Int64Value
	//	*Metric_Data_DoubleValue
	//	*Metric_Data_DistributionValue
	Value                isMetric_Data_Value `protobuf_oneof:"Value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Metric_Data) Reset()         { *m = Metric_Data{} }
func (m *Metric_Data) String() string { return proto.CompactTextString(m) }
func (*Metric_Data) ProtoMessage()    {}
func (*Metric_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{2, 0}
}

func (m *Metric_Data) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric_Data.Unmarshal(m, b)
}
func (m *Metric_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric_Data.Marshal(b, m, deterministic)
}
func (m *Metric_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric_Data.Merge(m, src)
}
func (m *Metric_Data) XXX_Size() int {
	return xxx_messageInfo_Metric_Data.Size(m)
}
func (m *Metric_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Metric_Data proto.InternalMessageInfo

func (m *Metric_Data) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Metric_Data) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Metric_Data) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

type isMetric_Data_Value interface {
	isMetric_Data_Value()
}

type Metric_Data_Int64Value struct {
	Int64Value int64 `protobuf:"varint,4,opt,name=int64_value,json=int64Value,proto3,oneof"`
}

type Metric_Data_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

type Metric_Data_DistributionValue struct {
	DistributionValue *Distribution `protobuf:"bytes,6,opt,name=distribution_value,json=distributionValue,proto3,oneof"`
}

func (*Metric_Data_Int64Value) isMetric_Data_Value() {}

func (*Metric_Data_DoubleValue) isMetric_Data_Value() {}

func (*Metric_Data_DistributionValue) isMetric_Data_Value() {}

func (m *Metric_Data) GetValue() isMetric_Data_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Metric_Data) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*Metric_Data_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *Metric_Data) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*Metric_Data_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *Metric_Data) GetDistributionValue() *Distribution {
	if x, ok := m.GetValue().(*Metric_Data_DistributionValue); ok {
		return x.DistributionValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Metric_Data) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Metric_Data_Int64Value)(nil),
		(*Metric_Data_DoubleValue)(nil),
		(*Metric_Data_DistributionValue)(nil),
	}
}

// Defines a metric type and its schema.
type MetricDescriptor struct {
	// name of the metric, including its DNS name prefix. It must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description of the metric, which can be used in documentation.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit        string                       `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	Temporality MetricDescriptor_Temporality `protobuf:"varint,4,opt,name=temporality,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality" json:"temporality,omitempty"`
	// monotonic is true if the metric values are entirely non-increasing, or
	// entirely non-decreasing.
	Monotonic bool                    `protobuf:"varint,5,opt,name=monotonic,proto3" json:"monotonic,omitempty"`
	Domain    MetricDescriptor_Domain `protobuf:"varint,6,opt,name=domain,proto3,enum=opentelemetry.proto.metrics.v1.MetricDescriptor_Domain" json:"domain,omitempty"`
	// The set of labels associated with the metric descriptor. Labels in this
	// list apply to all data points.
	Labels               []*v11.StringKeyValue `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MetricDescriptor) Reset()         { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()    {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{3}
}

func (m *MetricDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricDescriptor.Unmarshal(m, b)
}
func (m *MetricDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricDescriptor.Marshal(b, m, deterministic)
}
func (m *MetricDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricDescriptor.Merge(m, src)
}
func (m *MetricDescriptor) XXX_Size() int {
	return xxx_messageInfo_MetricDescriptor.Size(m)
}
func (m *MetricDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricDescriptor proto.InternalMessageInfo

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetTemporality() MetricDescriptor_Temporality {
	if m != nil {
		return m.Temporality
	}
	return MetricDescriptor_UNSPECIFIED
}

func (m *MetricDescriptor) GetMonotonic() bool {
	if m != nil {
		return m.Monotonic
	}
	return false
}

func (m *MetricDescriptor) GetDomain() MetricDescriptor_Domain {
	if m != nil {
		return m.Domain
	}
	return MetricDescriptor_NONE
}

func (m *MetricDescriptor) GetLabels() []*v11.StringKeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Distribution is a data point in a timeseries containing statistics for
// an observed population of values.
type Distribution struct {
	// count is the number of values in a population.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// sum is the total sum of all values in a population.
	Sum float64 `protobuf:"fixed64,2,opt,name=sum,proto3" json:"sum,omitempty"`
	// minimum is the minimum observed value in a population.
	Minimum float64 `protobuf:"fixed64,3,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// maximum is the maximum observed value in a population.
	Maximum float64 `protobuf:"fixed64,4,opt,name=maximum,proto3" json:"maximum,omitempty"`
	// buckets is an optional field contains the values of histogram for each bucket.
	//
	// The sum of the values in the buckets "count" field must equal the value in the count field.
	//
	// The number of elements in buckets array must be by one greater than the
	// number of elements in bucket_bounds array.
	//
	// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
	// must also be present and number of elements in this field must be equal to the
	// number of buckets defined by bucket_options.
	Buckets []*Distribution_Bucket `protobuf:"bytes,5,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// explicit_bounds specifies buckets with explicitly defined bounds for values.
	// The bucket boundaries are described by "bounds" field.
	//
	// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
	// at index i are:
	//
	// [0, bounds[i]) for i == 0
	// [bounds[i-1], bounds[i]) for 0 < i < N-1
	// [bounds[i], +infinity) for i == N-1
	// The values in bounds array must be strictly increasing and > 0.
	//
	// Note: only [a, b) intervals are currently supported for each bucket. If we decides
	// to also support (a, b] intervals we should add support for these by defining a boolean
	// value which decides what type of intervals to use.
	ExplicitBounds       []float64 `protobuf:"fixed64,6,rep,packed,name=explicit_bounds,json=explicitBounds,proto3" json:"explicit_bounds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Distribution) Reset()         { *m = Distribution{} }
func (m *Distribution) String() string { return proto.CompactTextString(m) }
func (*Distribution) ProtoMessage()    {}
func (*Distribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4}
}

func (m *Distribution) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution.Unmarshal(m, b)
}
func (m *Distribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution.Marshal(b, m, deterministic)
}
func (m *Distribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution.Merge(m, src)
}
func (m *Distribution) XXX_Size() int {
	return xxx_messageInfo_Distribution.Size(m)
}
func (m *Distribution) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution proto.InternalMessageInfo

func (m *Distribution) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Distribution) GetMinimum() float64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *Distribution) GetMaximum() float64 {
	if m != nil {
		return m.Maximum
	}
	return 0
}

func (m *Distribution) GetBuckets() []*Distribution_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Distribution) GetExplicitBounds() []float64 {
	if m != nil {
		return m.ExplicitBounds
	}
	return nil
}

// Bucket contains values for a bucket.
type Distribution_Bucket struct {
	// The number of values in each bucket of the histogram, as described by
	// bucket_options.
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// exemplar is an optional representative value of the bucket.
	Exemplar             *Distribution_Bucket_Exemplar `protobuf:"bytes,2,opt,name=exemplar,proto3" json:"exemplar,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Distribution_Bucket) Reset()         { *m = Distribution_Bucket{} }
func (m *Distribution_Bucket) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket) ProtoMessage()    {}
func (*Distribution_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0}
}

func (m *Distribution_Bucket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket.Unmarshal(m, b)
}
func (m *Distribution_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket.Merge(m, src)
}
func (m *Distribution_Bucket) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket.Size(m)
}
func (m *Distribution_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket proto.InternalMessageInfo

func (m *Distribution_Bucket) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Distribution_Bucket) GetExemplar() *Distribution_Bucket_Exemplar {
	if m != nil {
		return m.Exemplar
	}
	return nil
}

// Exemplars are example points that may be used to annotate aggregated
// Histogram values. They are metadata that gives information about a
// particular value added to a Histogram bucket.
type Distribution_Bucket_Exemplar struct {
	// Value of the exemplar point. It determines which bucket the exemplar belongs to.
	// If bucket_options define bounds for this bucket then this value must be within
	// the defined bounds.
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	// time_unix_nano is the moment when this exemplar was recorded.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	TimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=time_unix_nano,json=timeUnixNano,proto3" json:"time_unix_nano,omitempty"`
	// exemplar_attachments are contextual information about the example value.
	// Keys in this list must be unique.
	Attachments          []*v11.StringKeyValue `protobuf:"bytes,3,rep,name=attachments,proto3" json:"attachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Distribution_Bucket_Exemplar) Reset()         { *m = Distribution_Bucket_Exemplar{} }
func (m *Distribution_Bucket_Exemplar) String() string { return proto.CompactTextString(m) }
func (*Distribution_Bucket_Exemplar) ProtoMessage()    {}
func (*Distribution_Bucket_Exemplar) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c3112f9fa006917, []int{4, 0, 0}
}

func (m *Distribution_Bucket_Exemplar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Unmarshal(m, b)
}
func (m *Distribution_Bucket_Exemplar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Marshal(b, m, deterministic)
}
func (m *Distribution_Bucket_Exemplar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Distribution_Bucket_Exemplar.Merge(m, src)
}
func (m *Distribution_Bucket_Exemplar) XXX_Size() int {
	return xxx_messageInfo_Distribution_Bucket_Exemplar.Size(m)
}
func (m *Distribution_Bucket_Exemplar) XXX_DiscardUnknown() {
	xxx_messageInfo_Distribution_Bucket_Exemplar.DiscardUnknown(m)
}

var xxx_messageInfo_Distribution_Bucket_Exemplar proto.InternalMessageInfo

func (m *Distribution_Bucket_Exemplar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetTimeUnixNano() uint64 {
	if m != nil {
		return m.TimeUnixNano
	}
	return 0
}

func (m *Distribution_Bucket_Exemplar) GetAttachments() []*v11.StringKeyValue {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Temporality", MetricDescriptor_Temporality_name, MetricDescriptor_Temporality_value)
	proto.RegisterEnum("opentelemetry.proto.metrics.v1.MetricDescriptor_Domain", MetricDescriptor_Domain_name, MetricDescriptor_Domain_value)
	proto.RegisterType((*ResourceMetrics)(nil), "opentelemetry.proto.metrics.v1.ResourceMetrics")
	proto.RegisterType((*InstrumentationLibraryMetrics)(nil), "opentelemetry.proto.metrics.v1.InstrumentationLibraryMetrics")
	proto.RegisterType((*Metric)(nil), "opentelemetry.proto.metrics.v1.Metric")
	proto.RegisterType((*Metric_Data)(nil), "opentelemetry.proto.metrics.v1.Metric.Data")
	proto.RegisterType((*MetricDescriptor)(nil), "opentelemetry.proto.metrics.v1.MetricDescriptor")
	proto.RegisterType((*Distribution)(nil), "opentelemetry.proto.metrics.v1.Distribution")
	proto.RegisterType((*Distribution_Bucket)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket")
	proto.RegisterType((*Distribution_Bucket_Exemplar)(nil), "opentelemetry.proto.metrics.v1.Distribution.Bucket.Exemplar")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/metrics/v1/metrics.proto", fileDescriptor_3c3112f9fa006917)
}

var fileDescriptor_3c3112f9fa006917 = []byte{
	// 895 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x23, 0x35,
	0x14, 0xae, 0x33, 0xf9, 0x3d, 0x53, 0xd2, 0xd4, 0x5a, 0x41, 0x14, 0xb1, 0x90, 0x0d, 0x08, 0x02,
	0x6c, 0x27, 0xb4, 0xbb, 0xc0, 0x0d, 0x68, 0x69, 0x36, 0x03, 0x8d, 0x68, 0x27, 0x95, 0x93, 0xac,
	0x10, 0xd2, 0x12, 0x39, 0x89, 0xd5, 0xb5, 0xc8, 0xd8, 0xd1, 0x8c, 0xa7, 0x4a, 0x1f, 0x80, 0x17,
	0xe0, 0x86, 0xe7, 0x42, 0xe2, 0x01, 0x78, 0x0a, 0xb8, 0x04, 0x8d, 0x3d, 0xd3, 0x4e, 0xab, 0xb4,
	0xd9, 0xb2, 0x77, 0xc7, 0xdf, 0xf9, 0xce, 0xe7, 0xe3, 0xcf, 0x27, 0x13, 0xc3, 0x63, 0xb9, 0x64,
	0x42, 0xb1, 0x05, 0xf3, 0x99, 0x0a, 0x2e, 0x3a, 0xcb, 0x40, 0x2a, 0xd9, 0x89, 0x63, 0x3e, 0x0b,
	0x3b, 0xe7, 0xfb, 0x69, 0xe8, 0xe8, 0x04, 0x7e, 0xef, 0x1a, 0xdb, 0x80, 0x4e, 0x4a, 0x39, 0xdf,
	0x6f, 0x7c, 0xba, 0x4e, 0x6d, 0x26, 0x7d, 0x5f, 0x8a, 0x58, 0xcc, 0x44, 0xa6, 0xac, 0xe1, 0xac,
	0xe3, 0x06, 0x2c, 0x94, 0x51, 0x30, 0x63, 0x31, 0x3b, 0x8d, 0x0d, 0xbf, 0xf5, 0x17, 0x82, 0x1d,
	0x92, 0x40, 0x27, 0x66, 0x4b, 0xec, 0x42, 0x39, 0x65, 0xd5, 0x51, 0x13, 0xb5, 0xed, 0x83, 0x4f,
	0x9c, 0x75, 0x2d, 0x5e, 0x4a, 0x9d, 0xef, 0x3b, 0xa9, 0x06, 0xb9, 0x2c, 0xc5, 0xbf, 0x22, 0x78,
	0x9f, 0x8b, 0x50, 0x05, 0x91, 0xcf, 0x84, 0xa2, 0x8a, 0x4b, 0x31, 0x59, 0xf0, 0x69, 0x40, 0x83,
	0x8b, 0x49, 0x72, 0xba, 0x7a, 0xae, 0x69, 0xb5, 0xed, 0x83, 0x6f, 0x9c, 0xbb, 0x1d, 0x70, 0xfa,
	0xd7, 0x65, 0x8e, 0x8d, 0x4a, 0xd2, 0x2f, 0x79, 0xc8, 0xef, 0x4a, 0xb7, 0xfe, 0x40, 0xf0, 0xf0,
	0x4e, 0x01, 0x2c, 0xe0, 0x9d, 0x5b, 0x1a, 0x4d, 0xce, 0xff, 0xc5, 0xda, 0x06, 0x13, 0xe3, 0x6f,
	0xed, 0x8f, 0xbc, 0xbd, 0xbe, 0x31, 0xfc, 0x2d, 0x94, 0xae, 0x1b, 0xf0, 0xd1, 0x26, 0x03, 0x4c,
	0xa7, 0x24, 0x2d, 0x6b, 0xfd, 0x6b, 0x41, 0xd1, 0x60, 0xf8, 0x25, 0xec, 0x1a, 0x74, 0x32, 0x67,
	0xe1, 0x2c, 0xe0, 0x4b, 0x25, 0x83, 0xa4, 0xed, 0xcf, 0x5f, 0x4f, 0xb6, 0x77, 0x59, 0x47, 0x6a,
	0xfe, 0x0d, 0x04, 0x3f, 0x83, 0xfc, 0x9c, 0x2a, 0x9a, 0x34, 0xfa, 0xd9, 0xeb, 0x29, 0x3a, 0x3d,
	0xaa, 0x28, 0xd1, 0x85, 0x8d, 0x3f, 0x73, 0x90, 0x8f, 0x97, 0xd8, 0x85, 0xe2, 0x82, 0x4e, 0xd9,
	0x22, 0xac, 0x23, 0xad, 0xb5, 0xb7, 0xc1, 0xd4, 0xa1, 0x0a, 0xb8, 0x38, 0xfb, 0x81, 0x5d, 0xbc,
	0xa0, 0x8b, 0x88, 0x91, 0xa4, 0x18, 0x77, 0xe0, 0x41, 0xa8, 0x68, 0xa0, 0x26, 0x8a, 0xfb, 0x6c,
	0x12, 0x09, 0xbe, 0x9a, 0x08, 0x2a, 0x64, 0x3d, 0xd7, 0x44, 0xed, 0x22, 0xd9, 0xd5, 0xb9, 0x11,
	0xf7, 0xd9, 0x58, 0xf0, 0x95, 0x47, 0x85, 0xc4, 0x1f, 0x42, 0xf5, 0x06, 0xd5, 0xd2, 0xd4, 0x6d,
	0x95, 0x65, 0x3d, 0x02, 0x9b, 0x0b, 0xf5, 0xe5, 0xd3, 0xc9, 0x79, 0xbc, 0x5b, 0x3d, 0xdf, 0x44,
	0x6d, 0xeb, 0x68, 0x8b, 0x80, 0x06, 0x75, 0x07, 0xf8, 0x03, 0xd8, 0x9e, 0xcb, 0x68, 0xba, 0x60,
	0x09, 0xa7, 0xd0, 0x44, 0x6d, 0x74, 0xb4, 0x45, 0x6c, 0x83, 0x1a, 0xd2, 0x4b, 0xc0, 0x73, 0x1e,
	0xaa, 0x80, 0x4f, 0x23, 0x3d, 0x48, 0x86, 0x5a, 0xd4, 0xf7, 0xf1, 0x78, 0x93, 0x7b, 0xbd, 0x4c,
	0xe5, 0xd1, 0x16, 0xd9, 0xcd, 0x2a, 0x69, 0xf9, 0x6e, 0x09, 0x0a, 0x3a, 0x68, 0xfd, 0x6d, 0x41,
	0xed, 0xe6, 0xf5, 0x61, 0x0c, 0x79, 0x41, 0x7d, 0xf3, 0xab, 0xad, 0x10, 0x1d, 0xe3, 0x26, 0xd8,
	0xe9, 0x60, 0x70, 0x29, 0xb4, 0x4d, 0x15, 0x92, 0x85, 0xe2, 0xaa, 0x48, 0x70, 0xa5, 0x6d, 0xa9,
	0x10, 0x1d, 0xe3, 0x9f, 0xc1, 0x56, 0xcc, 0x5f, 0xca, 0x80, 0x2e, 0xb8, 0xba, 0xd0, 0x76, 0x54,
	0x0f, 0xbe, 0xbe, 0xef, 0x3c, 0x39, 0xa3, 0x2b, 0x0d, 0x92, 0x15, 0xc4, 0xef, 0x42, 0xc5, 0x97,
	0x42, 0x2a, 0x29, 0xf8, 0x4c, 0x1b, 0x59, 0x26, 0x57, 0x00, 0x1e, 0x40, 0x71, 0x2e, 0x7d, 0xca,
	0x85, 0x36, 0xae, 0x7a, 0xf0, 0xd5, 0xbd, 0x37, 0xee, 0xe9, 0x72, 0x92, 0xc8, 0x64, 0x66, 0xaf,
	0xf4, 0x06, 0xb3, 0xd7, 0x3a, 0x06, 0x3b, 0x73, 0x22, 0xbc, 0x03, 0xf6, 0xd8, 0x1b, 0x9e, 0xba,
	0xcf, 0xfb, 0xdf, 0xf5, 0xdd, 0x5e, 0x6d, 0x0b, 0xef, 0xc2, 0x5b, 0x7d, 0x6f, 0x38, 0x3a, 0xf4,
	0x46, 0x87, 0x9e, 0x3b, 0x18, 0x0f, 0x6b, 0x08, 0x57, 0xa0, 0xd0, 0x73, 0x8f, 0x47, 0x87, 0xb5,
	0x1c, 0xae, 0x02, 0x3c, 0x1f, 0x9f, 0x8c, 0x8f, 0x0f, 0x47, 0xfd, 0x17, 0x6e, 0xcd, 0x6a, 0x3d,
	0x85, 0xa2, 0x69, 0x13, 0x97, 0x21, 0xef, 0x0d, 0x3c, 0xb7, 0xb6, 0x15, 0x4b, 0x7a, 0x03, 0xcf,
	0x73, 0xbf, 0x37, 0x24, 0x94, 0x00, 0xa7, 0x83, 0x61, 0x5f, 0x03, 0xb9, 0xd6, 0x3f, 0x16, 0x6c,
	0x67, 0xe7, 0x04, 0x3f, 0x80, 0xc2, 0x4c, 0x46, 0x42, 0xe9, 0x5b, 0xcf, 0x13, 0xb3, 0xc0, 0x35,
	0xb0, 0xc2, 0xc8, 0xd7, 0xd7, 0x8d, 0x48, 0x1c, 0xe2, 0x3a, 0x94, 0x7c, 0x2e, 0xb8, 0x1f, 0xf9,
	0xfa, 0xa6, 0x11, 0x49, 0x97, 0x3a, 0x43, 0x57, 0x3a, 0x93, 0x4f, 0x32, 0x66, 0x89, 0x4f, 0xa0,
	0x34, 0x8d, 0x66, 0xbf, 0x30, 0x15, 0xd6, 0x0b, 0xda, 0xb8, 0x27, 0xf7, 0x19, 0x61, 0xa7, 0xab,
	0x6b, 0x49, 0xaa, 0x81, 0x3f, 0x86, 0x1d, 0xb6, 0x5a, 0x2e, 0xf8, 0x8c, 0xab, 0xc9, 0x54, 0x46,
	0x62, 0x1e, 0xd6, 0x8b, 0x4d, 0xab, 0x8d, 0x48, 0x35, 0x85, 0xbb, 0x1a, 0x6d, 0xfc, 0x96, 0x83,
	0xa2, 0x29, 0xbe, 0xe5, 0x78, 0x3f, 0x42, 0x99, 0xad, 0x98, 0xbf, 0x5c, 0xd0, 0x40, 0x9f, 0xd1,
	0xde, 0x3c, 0x9c, 0x6b, 0x3a, 0x73, 0xdc, 0x44, 0x83, 0x5c, 0xaa, 0x35, 0x7e, 0x47, 0x50, 0x4e,
	0xe1, 0x78, 0x73, 0xf3, 0x03, 0x46, 0xda, 0x17, 0xb3, 0x58, 0xf3, 0x45, 0xc9, 0xad, 0xf9, 0xa2,
	0x0c, 0xc0, 0xa6, 0x4a, 0xd1, 0xd9, 0xab, 0xf8, 0xfb, 0x1f, 0xd6, 0xad, 0xff, 0x33, 0x78, 0x59,
	0x85, 0xae, 0x82, 0x47, 0x5c, 0x6e, 0x38, 0x65, 0x77, 0x3b, 0xf9, 0x53, 0x3b, 0x8d, 0x13, 0xa7,
	0xe8, 0xa7, 0x67, 0x67, 0x5c, 0xbd, 0x8a, 0xa6, 0xf1, 0x16, 0x9d, 0xb8, 0x74, 0xef, 0xea, 0x71,
	0x70, 0x4d, 0x69, 0xcf, 0x3c, 0x15, 0xce, 0x98, 0xe8, 0x9c, 0x65, 0xdf, 0x2a, 0xd3, 0xa2, 0x4e,
	0x3c, 0xf9, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x50, 0xe1, 0xd3, 0x01, 0xd4, 0x08, 0x00, 0x00,
}
