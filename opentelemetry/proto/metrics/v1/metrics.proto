// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/metrics/v1";

// A collection of InstrumentationLibraryMetrics from a Resource.
message ResourceMetrics {
  // The resource for the metrics in this message.
  // If this field is not set then no resource info is known.
  opentelemetry.proto.resource.v1.Resource resource = 1;

  // A list of metrics that originate from a resource.
  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

// A collection of Metrics produced by an InstrumentationLibrary.
message InstrumentationLibraryMetrics {
  // The instrumentation library information for the metrics in this message.
  // If this field is not set then no library info is known.
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  // A list of metrics that originate from an instrumentation library.
  repeated Metric metrics = 2;
}

// Metric represents a timeseries produced by a telemetry system.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a list of label keys (shown horizontally).
// - Data is a list of DataPoints (shown vertically).
// - DataPoint contains a list of label values and a value.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         |+-----+-----+   +-----+ |
//  |          |         ||label|label|...|label| |
//  |      data|--+      ||key1 |key2 |   |keyN | |
//  +----------+  |      |+-----+-----+   +-----+ |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
message Metric {
  // metric_descriptor describes the Metric.
  MetricDescriptor metric_descriptor = 1;

  repeated Data data = 2;

  message Data {
    // The set of labels that uniquely identify this timeseries.
    //
    // These labels take precedence over any labels with the same key defined
    // in the metric descriptor.
    repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

    // start_time_unix_nano is the beginning of a time interval over which
    // this data point was recorded. It MUST be represented as the UNIX Epoch
    // time in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970).
    // If zero, it is treated as unspecified and may be set by the receiver.
    //
    // If this data point is a part of a timeseries for an INSTANTANEOUS
    // metric, this value is ignored.
    //
    // If this data point is a part of a timeseries for a DELTA, or
    // CUMULATIVE metric, this value represents the instant before the
    // measuring time interval began (i.e. for time t to be in the measuring
    // interval than start_time_unix_nano < t <= time_unix_nano).
    //
    // This time MUST be reset so as to represent a new measurement lifetime
    // if this data point is part of a timeseries for a CUMULATIVE metric and
    // the metric value is reset to zero.
    fixed64 start_time_unix_nano = 2;

    // time_unix_nano is the time when this data point was recorded. It MUST
    // be represented as the UNIX Epoch time in nanoseconds (nanoseconds since
    // 00:00:00 UTC on 1 January 1970). If zero, it is treated as unspecified
    // and may be set by the receiver.
    fixed64 time_unix_nano = 3;

    // Value is the measured value.
    oneof Value {
      int64 int64_value = 4;
      double double_value = 5;
      Distribution distribution_value = 6;
    }
  }
}

// Defines a metric type and its schema.
message MetricDescriptor {
  // name of the metric, including its DNS name prefix. It must be unique.
  string name = 1;

  // description of the metric, which can be used in documentation.
  string description = 2;

  // unit in which the metric value is reported. Follows the format
  // described by http://unitsofmeasure.org/ucum.html.
  string unit = 3;

  // Interval describes how metric values are reported over time.
  enum Interval {
    // UNSPECIFIED is the default Interval, it MUST not be used.
    UNSPECIFIED = 0;

    // INSTANTANEOUS is a metric whose values are measured at a particular
    // instant.
    //
    // If an INSTANTANEOUS metric is reported over any time interval the
    // values are representative of distinct measurements within the
    // interval.
    INSTANTANEOUS = 1;

    // DELTA is a metric whose values are measured and successively added
    // over a reporting interval. The reported value represents the change
    // from the previous interval.
    //
    // Each reported value for a DELTA metric over a time interval is
    // self-contained, the values do not depend on values in other time
    // intervals. This is unlike a CUMMULATIVE metric where values are sums
    // of all measured events in the time interval and all previously
    // measured values of the metric.
    //
    // DELTA metrics are not guaranteed to be monotonic.
    DELTA = 2;

    // CUMULATIVE is a metric whose values are measured and successively
    // added to the lifetime total of the metric.
    //
    // Each reported value for a CUMULATIVE metric is the sum of all
    // measurements up to and including that one.
    //
    // CUMULATIVE metrics are not guaranteed to be monotonic.
    CUMULATIVE = 3;
  }
  Interval interval = 4;

  // monotonic is true if the metric values are entirely non-increasing, or
  // entirely non-decreasing.
  bool monotonic = 5;

  // Subset describes the subset of numbers metric values belong to if any.
  enum Subset {
    // NONE is the default, and means the metric values do not belong to any
    // subset.
    NONE = 0;

    // NONNEGATIVE is the set of numbers greater than or equal to zero.
    NONNEGATIVE = 1;

    // NONPOSITIVE is the set of numbers less than or equal to zero.
    NONPOSITIVE  = 2;
  }
  Subset subset = 6;

  // The set of labels associated with the metric descriptor. Labels in this
  // list apply to all data points.
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 7;
}

// Distribution is a data point in a timeseries containing statistics for
// an observed population of values.
message Distribution {
  // count is the number of values in a population.
  uint64 count = 1;

  // sum is the total sum of all values in a population.
  double sum = 2;

  double minimum = 3;
  double maximum = 4;

  repeated uint64 bucket_counts = 5;

  message BucketBounds {
    oneof BoundKinds {
      ExplicitBounds explicit_bounds = 1;
      LinearBounds linear_bounds = 2;
    }
  }
  BucketBounds bucket_bounds = 6;

  message Percentile {
    // The percentile of a distribution. Must be in the interval
    // [0.0, 100.0].
    double percentile = 1;

    // The value at the given percentile of a distribution.
    double value = 2;
  }
  repeated Percentile percentiles = 7;
}

// ExplicitBounds define arbitrarily defined bucket bounds.
//
// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket at
// index i are:
//
//   (-infinity, bounds[i]) for i == 0
//   [bounds[i-1], bounds[i]) for 0 < i < N-1
//   [bounds[i], +infinity) for i == N-1
message ExplicitBounds {
  // The values in bounds array must be monotonically increasing.
  repeated double bounds = 3;
}

// LinearBounds define evenly spaced bucket bounds.
//
// This defines number + 2 (= N) buckets. The boundaries for buckets at
// index i are:
//
// (-infinity, minimum) for i == 0
// [minimum + ((i-1)*width), minimum + (i*width)) for 0 < i < N-1
// [minimum + (number*width), +infinity) for i == N-1
message LinearBounds {
  uint64 number = 1;
  double width = 2;
  double minimum = 3;
}
