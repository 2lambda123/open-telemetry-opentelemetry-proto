// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/metrics/v1";

// A collection of InstrumentationLibraryMetrics from a Resource.
message ResourceMetrics {
  // The resource for the metrics in this message.
  // If this field is not set then no resource info is known.
  opentelemetry.proto.resource.v1.Resource resource = 1;

  // A list of metrics that originate from a resource.
  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

// A collection of Metrics produced by an InstrumentationLibrary.
message InstrumentationLibraryMetrics {
  // The instrumentation library information for the metrics in this message.
  // If this field is not set then no library info is known.
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  // A list of metrics that originate from an instrumentation library.
  repeated Metric metrics = 2;
}

// Metric represents a timeseries produced by a telemetry system.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a list of label keys (shown horizontally).
// - Data is a list of DataPoints (shown vertically).
// - DataPoint contains a list of label values and a value.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         |+-----+-----+   +-----+ |
//  |          |         ||label|label|...|label| |
//  |      data|--+      ||key1 |key2 |   |keyN | |
//  +----------+  |      |+-----+-----+   +-----+ |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
message Metric {
  // metric_descriptor describing this Metric.
  MetricDescriptor metric_descriptor = 1;

  // The following timestamps define the time interval over which all data
  // for this Metric were recorded. How each timestamp is interpreted and
  // its validity depend on the Temporality of this Metric.
  //
  // For an INSTANTANEOUS Metric, start_time_unix_nano is optional, but if
  // specified, it MUST equal end_time_unix_nano. The end_time_unix_nano
  // timestamp is the moment the data was recorded.
  //
  // For both a DELTA and CUMULATIVE Metric, start_time_unix_nano and
  // end_time_unix_nano specify a non-zero positive time interval:
  //
  //   start_time_unix_nano <= t < end_time_unix_nano
  //
  // All the data for a DELTA and CUMULATIVE Metric are interpreted as being
  // recorded over this time interval unless an additional valid time
  // interval is defined for individual data. In that case, only that
  // individual data is interpreted as being recorded over that different
  // interval.
  //
  // Time intervals for successive DELTA Metrics MUST be non-overlapping.
  // Each interval needs to define the unique time over which the Metric is
  // reported.
  //
  // For successive CUMULATIVE Metrics, the start_time_unix_nano MUST remain
  // the same until the cumulative value is reset. The end_time_unix_nano is
  // increased successively to expand the overlapping interval the Metric
  // series is defined.
  //
  // If any data specifies either timestamp itself, that time is interpreted
  // as overriding the times specified here. If all data for this Metric are
  // reported over the same time interval, data SHOULD NOT specify
  // overrides. Rather, the time interval SHOULD be uniformly defined here.

  // start_time_unix_nano is the beginning of the time interval over which
  // all data for this Metric were recorded. It MUST be represented as the
  // UNIX Epoch time in nanoseconds (nanoseconds since 00:00:00 UTC on 1
  // January 1970). If zero, it is treated as unspecified.
  fixed64 start_time_unix_nano = 2;

  // end_time_unix_nano is the end of the time interval over which all data
  // for this Metric were recorded. It MUST be represented as the UNIX Epoch
  // time in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970).
  // If zero, it is treated as unspecified and the end to the time interval
  // is define by the receiver as the time this data is received. It is
  // RECOMMENDED to not leave this unspecified.
  fixed64 end_time_unix_nano = 3;

  // Data values of this Metric.
  repeated Data data = 4;

  message Data {
    // The set of additional labels uniquely identifying this data.
    //
    // It is considered an error for Labels used here to have the same key
    // as those defined in this Metric's MetricDescriptor and MUST be
    // avoided. The handling of this error is left up to the receiver.
    repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

    // start_time_unix_nano is the beginning of the time interval over which
    // this data was recorded. It MUST be represented as the UNIX Epoch time
    // in nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
    // zero, it is treated as unspecified.
    fixed64 start_time_unix_nano = 2;

    // end_time_unix_nano is the end of the time interval over which this
    // data was recorded. It MUST be represented as the UNIX Epoch time in
    // nanoseconds (nanoseconds since 00:00:00 UTC on 1 January 1970). If
    // zero, it is treated as unspecified.
    fixed64 end_time_unix_nano = 3;

    // The following three fields are mutually exclusive and represent the
    // measured value. Only one of the following three fields can be
    // populated. The populated field MUST match the MetricDescriptor type.

    // int64_value contains the measured value for INT64 type Metrics.
    int64 int64_value = 4;

    // double_value contains the measured value for DOUBLE type Metrics.
    double double_value = 5;

    // distribution_value contains the measured value for DISTRIBUTION type
    // Metrics.
    Distribution distribution_value = 6;
  }
}

// MetricDescriptor describes the identifying attributes of a metric.
message MetricDescriptor {
  // name of the metric.
  string name = 1;

  // description of the metric. This description is commonly used in
  // documentation so it should be a human-readable explanation of the
  // metric.
  string description = 2;

  // unit in which the metric value is reported. Follows the format
  // described by http://unitsofmeasure.org/ucum.html.
  string unit = 3;

  // Type is the type of values a metric has.
  enum Type {
    // TYPE_INVALID is the default Type, it MUST not be used.
    TYPE_INVALID = 0;

    // INT64 values are represents as signed 64-bit integers.
    //
    // A Metric of this Type MUST assign values to the int64_value field in
    // its Data.
    INT64 = 1;

    // DOUBLE values are represents as double-precision floating-point
    // numbers.
    //
    // A Metric of this Type MUST assign values to the double_value field
    // in its Data.
    DOUBLE = 2;

    // DISTRIBUTION values are statistics for an observed population
    // represented. These statistics are represented as a Distribution
    // message.
    //
    // A Metric of this Type MUST assign values to the distribution_value
    // field in its Data.
    DISTRIBUTION = 3;
  }

  // type is the Type of values this metric has.
  Type type = 4;

  // Temporality is the temporal quality values of a metric have. It
  // describes how those values relate to the time interval over which they
  // are reported.
  enum Temporality {
    // TEMPORALITY_INVALID is the default Temporality, it MUST not be
    // used.
    TEMPORALITY_INVALID = 0;

    // INSTANTANEOUS is a metric whose values are measured at a particular
    // instant. The values are not aggregated over any time interval and are
    // unique per timestamp.
    INSTANTANEOUS = 1;

    // DELTA is a metric whose values are the aggregation of measurements
    // made over a time interval. Successive metrics contain aggregation of
    // values from continuous and non-overlapping intervals.
    //
    // The values for a DELTA metric are based only on the time interval
    // associated with one measurement cycle. There is no dependency on
    // previous measurements like is the case for CUMULATIVE metrics.
    //
    // For example, consider a system measuring the number of requests that
    // it receives every second and reports the sum of these requests as a
    // DELTA metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0+1 to
    //      t_0+2 with a value of 2.
    DELTA = 2;

    // CUMULATIVE is a metric whose values are the aggregation of
    // successively made measurements from a fixed start time until the last
    // reported measurement. This means that current values of a CUMULATIVE
    // metric depend on all previous measurements since the start time.
    // Because of this, the sender is required to retain this state in some
    // form. If this state is lost or invalidated, the CUMULATIVE metric
    // values MUST be reset and a new fixed start time following the last
    // reported measurement time sent MUST be used.
    //
    // For example, consider a system measuring the number of requests that
    // it receives every second and reports the sum of these requests as a
    // CUMULATIVE metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+2 with a value of 5.
    //   9. The system experiences a fault and loses state.
    //   10. The system recovers and resumes receiving at time=t_1.
    //   11. A request is received, the system measures 1 request.
    //   12. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_1 to
    //      t_0+1 with a value of 1.
    CUMULATIVE = 3;
  }

  // temporality is the Temporality of values this metric has.
  Temporality temporality = 5;

  // Monotonic is a refinement of the values a metric has. It defines the
  // relationship values of successively reported metrics have
  // (non-increasing, non-decreasing, or unknown). This is a refinement of
  // the metric values that can be useful for a receiver in understanding
  // how to deal with discontinuities in the data (i.e.  calculating
  // derivates of the data without introducing artifacts from a reset).
  enum Monotonic {
    // MONOTONIC_UNSPECIFIED is the default, and means the monotonic nature
    // of the metric values is unknown.
    MONOTONIC_UNSPECIFIED = 0;

    // NONDECREASING means all the successive metric values increase or
    // remain constant.
    NONDECREASING = 1;
  }

  // monotonic describes the Monotonic refinement of values this metric has.
  Monotonic monotonic = 6;

  // Domain is a refinement of the values a metric has. It describes the set
  // of numbers metric values belong to, if any.
  enum Domain {
    // DOMAIN_UNSPECIFIED is the default, and means the metric values do
    // not belong to any particular domain other than the Type itself.
    DOMAIN_UNSPECIFIED = 0;

    // NONNEGATIVE is the set of numbers greater than or equal to zero.
    NONNEGATIVE = 1;
  }

  // domain describes the Domain refinement of values this metric has.
  Domain domain = 7;

  // The set of labels associated with the metric descriptor. Labels in this
  // list apply to all data points.
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 8;
}

// Distribution is a data point in a timeseries containing statistics for
// an observed population of values.
message Distribution {
  // count is the number of values in a population.
  uint64 count = 1;

  // sum is the total sum of all values in a population.
  double sum = 2;

  // minimum is the minimum observed value in a population.
  double minimum = 3;

  // maximum is the maximum observed value in a population.
  double maximum = 4;

  // Bucket contains values for a bucket.
  message Bucket {
    // The number of values in each bucket of the histogram, as described by
    // bucket_options.
    uint64 count = 1;

    // Exemplars are example points that may be used to annotate aggregated
    // Histogram values. They are metadata that gives information about a
    // particular value added to a Histogram bucket.
    message Exemplar {
      // Value of the exemplar point. It determines which bucket the exemplar belongs to.
      // If bucket_options define bounds for this bucket then this value must be within
      // the defined bounds.
      double value = 1;

      // end_time_unix_nano is the moment when this exemplar was recorded.
      // Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
      fixed64 end_time_unix_nano = 2;

      // exemplar_attachments are contextual information about the example value.
      // Keys in this list must be unique.
      repeated opentelemetry.proto.common.v1.StringKeyValue attachments = 3;
    }

    // exemplar is an optional representative value of the bucket.
    Exemplar exemplar = 2;
  }

  // buckets is an optional field contains the values of histogram for each bucket.
  //
  // The sum of the values in the buckets "count" field must equal the value in the count field.
  //
  // The number of elements in buckets array must be by one greater than the
  // number of elements in bucket_bounds array.
  //
  // Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  // must also be present and number of elements in this field must be equal to the
  // number of buckets defined by bucket_options.
  repeated Bucket buckets = 5;

  // A histogram may optionally contain the distribution of the values in the population.
  // In that case one of the option fields below and "buckets" field both must be defined.
  // Otherwise all option fields and "buckets" field must be omitted in which case the
  // distribution of values in the histogram is unknown and only the total count and sum are known.

  // explicit_bounds is the only supported bucket option currently.
  // TODO: Add more bucket options.

  // explicit_bounds specifies buckets with explicitly defined bounds for values.
  // The bucket boundaries are described by "bounds" field.
  //
  // This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  // at index i are:
  //
  // [0, bounds[i]) for i == 0
  // [bounds[i-1], bounds[i]) for 0 < i < N-1
  // [bounds[i], +infinity) for i == N-1
  // The values in bounds array must be strictly increasing and > 0.
  //
  // Note: only [a, b) intervals are currently supported for each bucket. If we decides
  // to also support (a, b] intervals we should add support for these by defining a boolean
  // value which decides what type of intervals to use.
  repeated double explicit_bounds = 6;
}
