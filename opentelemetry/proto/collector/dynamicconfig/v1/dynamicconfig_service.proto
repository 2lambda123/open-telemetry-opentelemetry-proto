// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.collector.dynamicconfig.v1;

import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.collector.dynamicconfig.v1";
option java_outer_classname = "DynamicConfigServiceProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/collector/dynamicconfig/v1";

// DynamicConfig is a service that enables updating metric schedules, trace
// parameters, and other configurations on an agent/SDK without having to
// restart the instrumented application. The server itself is hosted on the
// collector. In this way, the collector may act as a bridge between third-
// party configuration services and the agent/sdk, piping updated configs
// from a third-party source (or itself) to an instrumented application.
service DynamicConfig {
  rpc GetConfig (ConfigRequest) returns (ConfigResponse);
}

message ConfigRequest{
  // Describes the version of the config service protocol to use. Required.
  int32 proto_version = 1;

  // The target resource. This resource pings the config server requesting
  // updated configs, and the server responds with the config information.
  opentelemetry.proto.resource.v1.Resource resource = 2;

  // Optional. Identifies the last configuration fingerprint / version number.
  // The fingerprint serves as a quick way for the config server to determine
  // whether an update to the configs had occurred -- if the client request's
  // fingerprint differs from the server's, then the server knows that a change
  // had occured and an updated configuration should be sent.
  string last_fingerprint = 3;

  // An opaque string subject to individual implementation interpretation.
  // Responsability to interpret and check safety of metadata falls on the
  // specific implementation.
  string metadata = 4;
}

message ConfigResponse {
  // Describe the version of the config service protocol to use. Should match
  // the requestâ€™s version.
  int32 proto_version = 1;

  // The fingerprint associated with the current config settings. Each change in
  // configs yields a different fingerprint. The client may cache a fingerprint,
  // then return it on the next request to enable the server to quickly check
  // whether a change in the configs occured.
  string fingerprint = 2;

  // Configs specific to metric, namely the metric collection schedule
  message MetricConfig {

    // A Schedule is used to apply a particular scheduling configuration to
    // a metric. If a metric name matches a schedule's patterns, then the metric
    // adopts the configuration specified by the scheduel.
    message Schedule {

      // Pattern dictates a light-weight pattern that can match 1 or more
      // metrics, for which this schedule will apply. The string is used to
      // match against metric names. It should not exceed 100k characters.
      message Pattern {
        oneof match {
          string equals = 1;       // matches the metric name exactly
          string starts_with = 2;  // prefix-matches the metric name
        }
      }

      // Metrics with names that match a rule in the inclusion_patterns are
      // targeted by this schedule. Metrics that match the exclusion_patterns
      // are not targeted for this schedule, even if they match an inclusion
      // pattern.
      repeated Pattern inclusion_patterns = 1;
      repeated Pattern exclusion_patterns = 2;

      // CollectionPeriod describes the sampling period for each metric. All
      // larger units are divisible by all smaller ones.
      enum CollectionPeriod {
        NONE = 0;   // For non-periodic data. Client decides when to send points
        SEC_1 = 1;
        SEC_5 = 5;
        SEC_10 = 10;
        SEC_30 = 30;
        MIN_1 = 60;
        MIN_5 = 300;
        MIN_10 = 600;
        MIN_30 = 1800;
        HR_1 = 3600;
        HR_2 = 7200;
        HR_4 = 14400;
        HR_12 = 43200;
        DAY_1 = 86400;
        DAY_7 = 604800;
      }
      CollectionPeriod period = 3;

      // Additional metadata associated with the schedule. Responsability to
      // interpret and check safety of metadata falls on the specific
      // implementation
      string metadata = 4;
    }

    // A single metric may match multiple schedules. This behavior enables a use
    // case in which metadata properties may distinguish different collection
    // periods for the same metric.
    //
    // For example, suppose an implementation uses a "traffic class" metadata
    // property to determine the priority given to sampling a certain metric.
    // Then a schedule may be applied in which a metric is sampled with high
    // priority at an infrequent period, but with low priority at a frequent
    // period.
    //
    // In the event no distinguishing metadata is applied to a metric that
    // mutches multiple schedules, the schedule that specifies the smallest
    // period is applied.
    //
    // Note, for optimization purposes, it is best practice to use as few
    // schedules as possible to capture all required metric updates. Where you
    // can be conservative, do take full advantage of the inclusion/exclusion
    // patterns to capture as much of your targeted metrics.
    repeated Schedule schedules = 1;

  }
  MetricConfig metric_config = 3;

  message TraceConfig {
    // TODO: unimplemented
  }
  TraceConfig trace_config = 4;

  // The client is suggested to wait this long (in seconds) before pinging the
  // configuration service again.
  int32 suggested_wait_time = 5;
}
