// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.collector.dynamicconfig.v1;

import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.collector.dynamicconfig.v1";
option java_outer_classname = "DynamicConfigServiceProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/collector/dynamicconfig/v1";

// DynamicConfig is a service on the collector that enables updating metric
// schedules, trace parameters, and other configurations on an agent/SDK without
// having to restart the instrumented application. The collector may also act as
// a bridge between third-party configuration services and the agent/sdk, piping
// updated configs from a third-party source to an instrumented application.
service DynamicConfig {
  rpc GetConfig (ConfigRequest) returns (ConfigResponse);
}

message ConfigRequest{

  // Required. The resource for which configuration should be returned.
  opentelemetry.proto.resource.v1.Resource resource = 2;

  // Optional. The value of ConfigResponse.fingerprint for the last configuration
  // a resource received, regardless whether it was successfully applied.
  bytes last_known_fingerprint = 3;
}

message ConfigResponse {

  // Optional. The fingerprint associated with this ConfigResponse. Each change
  // in configs yields a different fingerprint. The resource SHOULD copy this
  // value to ConfigRequest.last_known_fingerprint for the next configuration
  // request. If there are no changes between fingerprint and
  // ConfigRequest.last_known_fingerprint, then all other fields besides
  // fingerprint in the response are optional, or the same as the last update if
  // present.
  //
  // The exact mechanics of generating the fingerprint is up to the
  // implementation. However, a fingerprint must be deterministically determined
  // by the configurations -- the same configuration will generate the same
  // fingerprint on any instance of an implementation. Hence using a timestamp is
  // unacceptable, but a deterministic hash is fine.
  bytes fingerprint = 2;

  // Dynamic configs specific to metrics
  message MetricConfig {

    // A Schedule is used to apply a particular scheduling configuration to
    // a metric. If a metric name matches a schedule's patterns, then the metric
    // adopts the configuration specified by the schedule.
    message Schedule {

      // A light-weight pattern that can match 1 or more
      // metrics, for which this schedule will apply. The string is used to
      // match against metric names. It should not exceed 100k characters.
      message Pattern {
        oneof match {
          string equals = 1;       // matches the metric name exactly
          string starts_with = 2;  // prefix-matches the metric name
        }
      }

      // Metrics with names that match a rule in the inclusion_patterns are
      // targeted by this schedule. Metrics that match the exclusion_patterns
      // are not targeted for this schedule, even if they match an inclusion
      // pattern.
      repeated Pattern inclusion_patterns = 1;
      repeated Pattern exclusion_patterns = 2;

      // CollectionPeriod describes the sampling period for each metric. All
      // larger units are divisible by all smaller ones.
      enum CollectionPeriod {
        NONE = 0;  // For non-periodic data (client sends points whenever)
        SEC_1 = 1;
        SEC_5 = 5;
        SEC_10 = 10;
        SEC_30 = 30;
        MIN_1 = 60;
        MIN_5 = 300;
        MIN_10 = 600;
        MIN_30 = 1800;
        HR_1 = 3600;
        HR_2 = 7200;
        HR_4 = 14400;
        HR_12 = 43200;
        DAY_1 = 86400;
        DAY_7 = 604800;
      }
      CollectionPeriod period = 3;

      // Optional. Additional opaque metadata associated with the schedule.
      // Interpreting metadata is implementation specific. A metric backend may
      // implement features not directly supported in this configuration
      // protocol, but still desire to communicate these settings to
      // instrumented applications. An application may in turn piggyback
      // metadata on a vendor's metric exporter to communicate information back
      // to its metric backend. In this way, metadata offers a channel to
      // communicate custom settings.
      //
      // Example use cases may include:
      //  * Specifying quality-of-service priority
      //  * Tweaking configurations beyond collection period
      //  * Using alternate representations for collection schedules, matching
      //    metrics, resources, etc.
      //  * Enabling other optimizations
      bytes metadata = 4;
    }

    // A single metric may match multiple schedules. This behavior enables a use
    // case in which metadata properties may distinguish different collection
    // periods for the same metric.
    //
    // For example, suppose an implementation uses a "traffic class" metadata
    // property to determine the priority given to sampling a certain metric.
    // Then one schedule may be applied in which a metric is sampled with high
    // priority at an infrequent period, but another schedule may be applied
    // with low priority at a frequent period.
    //
    // In the event no distinguishing metadata is applied to a metric that
    // matches multiple schedules, the schedule that specifies the smallest
    // period is applied.
    //
    // Note, for optimization purposes, it is best practice to use as few
    // schedules as possible to capture all required metric updates. Where you
    // can be conservative, do take full advantage of the inclusion/exclusion
    // patterns to capture as much of your targeted metrics.
    repeated Schedule schedules = 1;

  }
  MetricConfig metric_config = 3;

  // Dynamic configs specific to trace, like sampling rate of a resource.
  message TraceConfig {
    // TODO: unimplemented
  }
  TraceConfig trace_config = 4;

  // Optional. The client is suggested to wait this long (in seconds) before
  // pinging the configuration service again.
  int32 suggested_wait_time_sec = 5;
}
