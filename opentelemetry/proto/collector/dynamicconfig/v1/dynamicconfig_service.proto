// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.collector.dynamicconfig.v1;

import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.collector.dynamicconfig.v1";
option java_outer_classname = "DynamicConfigServiceProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/collector/dynamicconfig/v1";

// DynamicConfig is a service that enables updating metric schedules, trace
// parameters, and other configurations on an agent/SDK without having to
// restart the instrumented application. The server itself is hosted on the
// collector. In this way, the collector may act as a bridge between third-
// party configuration services and the agent/sdk, piping updated configs
// from a third-party source (or itself) to an instrumented application.
service DynamicConfig {
  rpc GetConfig (ConfigRequest) returns (ConfigResponse);
}

message ConfigRequest{
  // Describes the version of the config service protocol to use. Required.
  int32 proto_version = 1;

  // The target resource. This resource pings the config server requesting
  // updated configs, and the server responds with the config information.
  opentelemetry.proto.resource.v1.Resource resource = 2;

  // Optional. Identifies the last configuration fingerprint / version number.
  // The fingerprint serves as a quick way for the config server to determine
  // whether an update to the configs had occurred -- if the client request's
  // fingerprint differs from the server's, then the server knows that a change
  // had occured and an updated configuration should be sent.
  int32 last_fingerprint = 3;

  // An opaque string subject to individual implementation interpretation.
  // Responsability to interpret and check safety of metadata falls on the
  // specific implementation.
  string metadata = 4;
}

message ConfigResponse {
  // Describe the version of the config service protocol to use. Should match
  // the requestâ€™s version.
  int32 proto_version = 1;

  // The fingerprint associated with the current config settings. Each change in
  // configs yields a different fingerpting. The client may cache a fingerprint,
  // then return it on the next request to enable the server to quickly check
  // whether a change in the configs occured.
  int32 fingerprint = 2;

  // Configs specific to metric, namely the metric collection schedule
  message MetricConfig {

    // A schedule is used to apply a particular scheduling configuration to
    // a metric
    message Schedule {

      // Metrics with names that match the inclusion_pattern are targeted by
      // this schedule. Metrics that match the exclusion_pattern are not
      // targeted for this schedule, even if they match the inclusion pattern.
      string inclusion_pattern = 1;
      string exclusion_pattern = 2;

      // CollectionPeriod describes the sampling period for each metric. All
      // larger units are divisible by all smaller ones.
      enum CollectionPeriod {
        NONE = 0;   // For non-periodic data. Client decides when to send points
        SEC_1 = 1;
        SEC_5 = 5;
        SEC_10 = 10;
        SEC_30 = 30;
        MIN_1 = 60;
        MIN_5 = 300;
        MIN_10 = 600;
        MIN_30 = 1800;
        HR_1 = 3600;
        HR_2 = 7200;
        HR_4 = 14400;
        HR_12 = 43200;
        DAY_1 = 86400;
        DAY_7 = 604800;
      }
      CollectionPeriod period = 3;

      // Additional metadata associated with the schedule. Responsability to
      // interpret and check safety of metadata falls on the specific
      // implementation
      string metadata = 4;
    }

    repeated Schedule collecting_schedules = 1;

  }
  MetricConfig metric_config = 3;

  message TraceConfig {
    // TODO: unimplemented
  }
  TraceConfig trace_config = 4;

  // The client is suggested to wait this long (in seconds) before pinging the
  // configuration service again.
  int32 suggested_wait_time = 5;
}
