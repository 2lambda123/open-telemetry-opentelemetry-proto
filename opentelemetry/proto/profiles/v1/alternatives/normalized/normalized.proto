syntax = "proto3";

package opentelemetry.proto.profiles.v1.alternatives.normalized;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option go_package = "go.opentelemetry.io/proto/otlp/profiles/v1/normalized";


// A pointer from a profile to a trace span.
message Link {
  // A unique identifier of a trace that this linked span is part of. The ID is a
  // 16-byte array.
  bytes trace_id = 1;
  // A unique identifier for the linked span. The ID is an 8-byte array.
  bytes span_id = 2;
}

// AttributeSet represents a set of attributes. It is referenced from Samples
// and not embedded because it is common for multiple samples to have the same
// set of attributes
message AttributeSet {
  repeated opentelemetry.proto.common.v1.KeyValue attributes = 1;
  uint32 dropped_attributes_count = 2;
}

message Stacktrace {
  repeated uint32 location_indices = 1;
}

message Sample {
  uint32 stacktrace_index = 1;
  repeated uint32 link_indices = 2;
  repeated uint32 attribute_set_indices = 3;

  // this one is repeated because there can be multiple profile kinds in one profile. Typical example is memory profiles in go that contain:
  //   * alloc_objects
  //   * alloc_bytes
  //   * inuse_objects
  //   * inuse_bytes
  repeated int64 values = 4;

  // optional
  fixed64 timestamp_unix_nano = 5;
}

message SampleType {
  // borrowed from metrics proto
  enum AggregationTemporality {
    AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
    AGGREGATION_TEMPORALITY_DELTA = 1;
    AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
  }

  AggregationTemporality aggregation_temporality = 1;
  uint64 sample_size = 2;

  // CPU / memory /etc
  uint32 type_index = 3; // Index into string table.
  uint32 unit_index = 4; // Index into string table.
}

message Profile {
  repeated SampleType sample_types = 1;
  repeated Stacktrace stacktraces = 2;
  repeated Sample samples = 3;
  repeated Mapping mappings = 4;
  repeated Location locations = 5;
  repeated Function functions = 6;
  repeated Link links = 7;
  repeated AttributeSet attribute_sets = 8;

  // 0-th element must be an empty string ("")
  repeated string string_table = 9;
}


// borrowed from pprof proto
message Mapping {
  // Address at which the binary (or DLL) is loaded into memory.
  uint64 memory_start = 1;
  // The limit of the address range occupied by this mapping.
  uint64 memory_limit = 2;
  // Offset in the binary that corresponds to the first mapped address.
  uint64 file_offset = 3;
  // The object this entry is loaded from.  This can be a filename on
  // disk for the main binary and shared libraries, or virtual
  // abstractions like "[vdso]".
  uint32 filename_index = 4;  // Index into string table
  // A string that uniquely identifies a particular program version
  // with high probability. E.g., for binaries generated by GNU tools,
  // it could be the contents of the .note.gnu.build-id field.
  uint32 build_id_index = 5;  // Index into string table

  enum SymbolicInfo {
    SYMBOLIC_INFO_UNSPECIFIED = 0;
    SYMBOLIC_INFO_FULL = 1;
    SYMBOLIC_INFO_FUNCTIONS_ONLY = 2;
    SYMBOLIC_INFO_NO_INLINE_FRAMES = 3;
  }

  SymbolicInfo symbolic_info = 6;

  // TODO(@petethepig): I wonder if we need something a little more specialized here
  repeated uint32 attribute_set_indices = 7;
}

// borrowed from pprof proto
// Describes function and line table debug information.
message Location {
  // The id of the corresponding profile.Mapping for this location.
  // It can be unset if the mapping is unknown or not applicable for
  // this profile type.
  uint32 mapping_index = 1;
  // The instruction address for this location, if available.  It
  // should be within [Mapping.memory_start...Mapping.memory_limit]
  // for the corresponding mapping. A non-leaf address may be in the
  // middle of a call instruction. It is up to display tools to find
  // the beginning of the instruction if necessary.
  uint64 address = 2;
  // Multiple line indicates this location has inlined functions,
  // where the last entry represents the caller into which the
  // preceding entries were inlined.
  //
  // E.g., if memcpy() is inlined into printf:
  //    line[0].function_name == "memcpy"
  //    line[1].function_name == "printf"
  repeated Line line = 3;
  // Provides an indication that multiple symbols map to this location's
  // address, for example due to identical code folding by the linker. In that
  // case the line information above represents one of the multiple
  // symbols. This field must be recomputed when the symbolization state of the
  // profile changes.
  bool is_folded = 4;

  // TODO(@petethepig): I wonder if we need something a little more specialized here
  repeated uint32 attribute_set_indices = 5;
}

// borrowed from pprof proto
message Line {
  // The id of the corresponding profile.Function for this line.
  uint32 function_index = 1;
  // Line number in source code.
  uint32 line = 2;
}

// borrowed from pprof proto
message Function {
  // Name of the function, in human-readable form if available.
  uint32 name_index = 1; // Index into string table
  // Name of the function, as identified by the system.
  // For instance, it can be a C++ mangled name.
  uint32 system_name_index = 2; // Index into string table
  // Source file containing the function.
  uint32 filename_index = 3; // Index into string table
  // Line number in source file.
  uint32 start_line = 4;
}
