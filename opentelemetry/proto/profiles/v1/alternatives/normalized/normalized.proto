syntax = "proto3";

package opentelemetry.proto.profiles.v1.alternatives.normalized;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option go_package = "go.opentelemetry.io/proto/otlp/profiles/v1/normalized";


// A pointer from a profile to a trace span.
message Link {
  // A unique identifier of a trace that this linked span is part of. The ID is a
  // 16-byte array.
  bytes trace_id = 1;
  // A unique identifier for the linked span. The ID is an 8-byte array.
  bytes span_id = 2;
}

message AttributeSet {
  repeated opentelemetry.proto.common.v1.KeyValue attributes = 1;
  uint32 dropped_attributes_count = 2;
}

message Sample {
  repeated uint64 location_ids = 1;
  repeated uint64 link_ids = 2;
  repeated uint64 attribute_set_ids = 3;

  // this one is repeated because there can be multiple profile kinds in one profile. Typical example is memory profiles in go that contain:
  //   * alloc_objects
  //   * alloc_bytes
  //   * inuse_objects
  //   * inuse_bytes
  repeated fixed64 values = 4;

  // optional
  fixed64 timestamp_unix_nano = 5;
}

// borrowed from metrics proto
enum AggregationTemporality {
  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
  AGGREGATION_TEMPORALITY_DELTA = 1;
  AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
}

message SampleType {
  AggregationTemporality aggregation_temporality = 1;
  uint64 sample_size = 2;

  // CPU / memory /etc
  int64 type = 3; // Index into string table.
  int64 unit = 4; // Index into string table.
}

message Profile {
  repeated SampleType sample_types = 1;
  repeated Sample samples = 2;
  repeated Mapping mappings = 3;
  repeated Location locations = 4;
  repeated Function functions = 5;
  repeated Link links = 6;
  repeated AttributeSet attribute_sets = 7;
  repeated string string_table = 8;
}


// borrowed from pprof proto
message Mapping {
  // Address at which the binary (or DLL) is loaded into memory.
  uint64 memory_start = 1;
  // The limit of the address range occupied by this mapping.
  uint64 memory_limit = 2;
  // Offset in the binary that corresponds to the first mapped address.
  uint64 file_offset = 3;
  // The object this entry is loaded from.  This can be a filename on
  // disk for the main binary and shared libraries, or virtual
  // abstractions like "[vdso]".
  int64 filename = 4;  // Index into string table
  // A string that uniquely identifies a particular program version
  // with high probability. E.g., for binaries generated by GNU tools,
  // it could be the contents of the .note.gnu.build-id field.
  int64 build_id = 5;  // Index into string table

  // The following fields indicate the resolution of symbolic info.
  bool has_functions = 6;
  bool has_filenames = 7;
  bool has_line_numbers = 8;
  bool has_inline_frames = 9;
}

// borrowed from pprof proto
// Describes function and line table debug information.
message Location {
  // The id of the corresponding profile.Mapping for this location.
  // It can be unset if the mapping is unknown or not applicable for
  // this profile type.
  uint64 mapping_id = 1;
  // The instruction address for this location, if available.  It
  // should be within [Mapping.memory_start...Mapping.memory_limit]
  // for the corresponding mapping. A non-leaf address may be in the
  // middle of a call instruction. It is up to display tools to find
  // the beginning of the instruction if necessary.
  uint64 address = 2;
  // Multiple line indicates this location has inlined functions,
  // where the last entry represents the caller into which the
  // preceding entries were inlined.
  //
  // E.g., if memcpy() is inlined into printf:
  //    line[0].function_name == "memcpy"
  //    line[1].function_name == "printf"
  repeated Line line = 3;
  // Provides an indication that multiple symbols map to this location's
  // address, for example due to identical code folding by the linker. In that
  // case the line information above represents one of the multiple
  // symbols. This field must be recomputed when the symbolization state of the
  // profile changes.
  bool is_folded = 4;
}

// borrowed from pprof proto
message Line {
  // The id of the corresponding profile.Function for this line.
  uint64 function_id = 1;
  // Line number in source code.
  int64 line = 2;
}

// borrowed from pprof proto
message Function {
  // Name of the function, in human-readable form if available.
  int64 name = 1; // Index into string table
  // Name of the function, as identified by the system.
  // For instance, it can be a C++ mangled name.
  int64 system_name = 2; // Index into string table
  // Source file containing the function.
  int64 filename = 3; // Index into string table
  // Line number in source file.
  int64 start_line = 4;
}
